{
  "instructions": [
    {
      "name": "nop",
      "format": "R",
      "description": "Null operation : machine code is all zeroes",
      "operandLayout": ""
    },
    {
      "name": "add",
      "format": "R",
      "description": "Addition with overflow : set $t1 to ($t2 plus $t3)",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "sub",
      "format": "R",
      "description": "Subtraction with overflow : set $t1 to ($t2 minus $t3)",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "addi",
      "format": "I",
      "description": "Addition immediate with overflow : set $t1 to ($t2 plus signed 16-bit immediate)",
      "operandLayout": "$t1,$t2,-100"
    },
    {
      "name": "addu",
      "format": "R",
      "description": "Addition unsigned without overflow : set $t1 to ($t2 plus $t3), no overflow",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "subu",
      "format": "R",
      "description": "Subtraction unsigned without overflow : set $t1 to ($t2 minus $t3), no overflow",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "addiu",
      "format": "I",
      "description": "Addition immediate unsigned without overflow : set $t1 to ($t2 plus signed 16-bit immediate), no overflow",
      "operandLayout": "$t1,$t2,-100"
    },
    {
      "name": "mult",
      "format": "R",
      "description": "Multiplication : Set hi to high-order 32 bits, lo to low-order 32 bits of the product of $t1 and $t2 (use mfhi to access hi, mflo to access lo)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "multu",
      "format": "R",
      "description": "Multiplication unsigned : Set HI to high-order 32 bits, LO to low-order 32 bits of the product of unsigned $t1 and $t2 (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "mul",
      "format": "R",
      "description": "Multiplication without overflow  : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and $t3 (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "madd",
      "format": "R",
      "description": "Multiply add : Multiply $t1 by $t2 then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "maddu",
      "format": "R",
      "description": "Multiply add unsigned : Multiply $t1 by $t2 then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "msub",
      "format": "R",
      "description": "Multiply subtract : Multiply $t1 by $t2 then decrement HI by high-order 32 bits of product, decrement LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "msubu",
      "format": "R",
      "description": "Multiply subtract unsigned : Multiply $t1 by $t2 then decrement HI by high-order 32 bits of product, decement LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "div",
      "format": "R",
      "description": "Division with overflow : Divide $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "divu",
      "format": "R",
      "description": "Division unsigned without overflow : Divide unsigned $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "mfhi",
      "format": "R",
      "description": "Move from HI register : Set $t1 to contents of HI (see multiply and divide operations)",
      "operandLayout": "$t1"
    },
    {
      "name": "mflo",
      "format": "R",
      "description": "Move from LO register : Set $t1 to contents of LO (see multiply and divide operations)",
      "operandLayout": "$t1"
    },
    {
      "name": "mthi",
      "format": "R",
      "description": "Move to HI registerr : Set HI to contents of $t1 (see multiply and divide operations)",
      "operandLayout": "$t1"
    },
    {
      "name": "mtlo",
      "format": "R",
      "description": "Move to LO register : Set LO to contents of $t1 (see multiply and divide operations)",
      "operandLayout": "$t1"
    },
    {
      "name": "and",
      "format": "R",
      "description": "Bitwise AND : Set $t1 to bitwise AND of $t2 and $t3",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "or",
      "format": "R",
      "description": "Bitwise OR : Set $t1 to bitwise OR of $t2 and $t3",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "andi",
      "format": "I",
      "description": "Bitwise AND immediate : Set $t1 to bitwise AND of $t2 and zero-extended 16-bit immediate",
      "operandLayout": "$t1,$t2,100"
    },
    {
      "name": "ori",
      "format": "I",
      "description": "Bitwise OR immediate : Set $t1 to bitwise OR of $t2 and zero-extended 16-bit immediate",
      "operandLayout": "$t1,$t2,100"
    },
    {
      "name": "nor",
      "format": "R",
      "description": "Bitwise NOR : Set $t1 to bitwise NOR of $t2 and $t3",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "xor",
      "format": "R",
      "description": "Bitwise XOR (exclusive OR) : Set $t1 to bitwise XOR of $t2 and $t3",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "xori",
      "format": "I",
      "description": "Bitwise XOR immediate : Set $t1 to bitwise XOR of $t2 and zero-extended 16-bit immediate",
      "operandLayout": "$t1,$t2,100"
    },
    {
      "name": "sll",
      "format": "R",
      "description": "Shift left logical : Set $t1 to result of shifting $t2 left by number of bits specified by immediate",
      "operandLayout": "$t1,$t2,10"
    },
    {
      "name": "sllv",
      "format": "R",
      "description": "Shift left logical variable : Set $t1 to result of shifting $t2 left by number of bits specified by value in low-order 5 bits of $t3",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "srl",
      "format": "R",
      "description": "Shift right logical : Set $t1 to result of shifting $t2 right by number of bits specified by immediate",
      "operandLayout": "$t1,$t2,10"
    },
    {
      "name": "sra",
      "format": "R",
      "description": "Shift right arithmetic : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by immediate",
      "operandLayout": "$t1,$t2,10"
    },
    {
      "name": "srav",
      "format": "R",
      "description": "Shift right arithmetic variable : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "srlv",
      "format": "R",
      "description": "Shift right logical variable : Set $t1 to result of shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "lw",
      "format": "I",
      "description": "Load word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "ll",
      "format": "I",
      "description": "Load linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "lwl",
      "format": "I",
      "description": "Load word left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "lwr",
      "format": "I",
      "description": "Load word right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "sw",
      "format": "I",
      "description": "Store word : Store contents of $t1 into effective memory word address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "sc",
      "format": "I",
      "description": "Store conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Stores $t1 value into effective address, then sets $t1 to 1 for success.  Always succeeds because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "swl",
      "format": "I",
      "description": "Store word left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "swr",
      "format": "I",
      "description": "Store word right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective byte address and continuing through that byte address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "lui",
      "format": "I",
      "description": "Load upper immediate : Set high-order 16 bits of $t1 to 16-bit immediate and low-order 16 bits to 0",
      "operandLayout": "$t1,100"
    },
    {
      "name": "beq",
      "format": "I-branch",
      "description": "Branch if equal : Branch to statement at label's address if $t1 and $t2 are equal",
      "operandLayout": "$t1,$t2,label"
    },
    {
      "name": "bne",
      "format": "I-branch",
      "description": "Branch if not equal : Branch to statement at label's address if $t1 and $t2 are not equal",
      "operandLayout": "$t1,$t2,label"
    },
    {
      "name": "bgez",
      "format": "I-branch",
      "description": "Branch if greater than or equal to zero : Branch to statement at label's address if $t1 is greater than or equal to zero",
      "operandLayout": "$t1,label"
    },
    {
      "name": "bgezal",
      "format": "I-branch",
      "description": "Branch if greater then or equal to zero and link : If $t1 is greater than or equal to zero, then set $ra to the Program Counter and branch to statement at label's address",
      "operandLayout": "$t1,label"
    },
    {
      "name": "bgtz",
      "format": "I-branch",
      "description": "Branch if greater than zero : Branch to statement at label's address if $t1 is greater than zero",
      "operandLayout": "$t1,label"
    },
    {
      "name": "blez",
      "format": "I-branch",
      "description": "Branch if less than or equal to zero : Branch to statement at label's address if $t1 is less than or equal to zero",
      "operandLayout": "$t1,label"
    },
    {
      "name": "bltz",
      "format": "I-branch",
      "description": "Branch if less than zero : Branch to statement at label's address if $t1 is less than zero",
      "operandLayout": "$t1,label"
    },
    {
      "name": "bltzal",
      "format": "I-branch",
      "description": "Branch if less than zero and link : If $t1 is less than or equal to zero, then set $ra to the Program Counter and branch to statement at label's address",
      "operandLayout": "$t1,label"
    },
    {
      "name": "slt",
      "format": "R",
      "description": "Set less than : If $t2 is less than $t3, then set $t1 to 1 else set $t1 to 0",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "sltu",
      "format": "R",
      "description": "Set less than unsigned : If $t2 is less than $t3 using unsigned comparision, then set $t1 to 1 else set $t1 to 0",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "slti",
      "format": "I",
      "description": "Set less than immediate : If $t2 is less than sign-extended 16-bit immediate, then set $t1 to 1 else set $t1 to 0",
      "operandLayout": "$t1,$t2,-100"
    },
    {
      "name": "sltiu",
      "format": "I",
      "description": "Set less than immediate unsigned : If $t2 is less than  sign-extended 16-bit immediate using unsigned comparison, then set $t1 to 1 else set $t1 to 0",
      "operandLayout": "$t1,$t2,-100"
    },
    {
      "name": "movn",
      "format": "R",
      "description": "Move conditional not zero : Set $t1 to $t2 if $t3 is not zero",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "movz",
      "format": "R",
      "description": "Move conditional zero : Set $t1 to $t2 if $t3 is zero",
      "operandLayout": "$t1,$t2,$t3"
    },
    {
      "name": "movf",
      "format": "R",
      "description": "Move if FP condition flag 0 false : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag 0 is false (zero)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "movf",
      "format": "R",
      "description": "Move if specified FP condition flag false : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is false (zero)",
      "operandLayout": "$t1,$t2,1"
    },
    {
      "name": "movt",
      "format": "R",
      "description": "Move if FP condition flag 0 true : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag 0 is true (one)",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "movt",
      "format": "R",
      "description": "Move if specfied FP condition flag true : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is true (one)",
      "operandLayout": "$t1,$t2,1"
    },
    {
      "name": "break",
      "format": "R",
      "description": "Break execution with code : Terminate program execution with specified exception code",
      "operandLayout": "100"
    },
    {
      "name": "break",
      "format": "R",
      "description": "Break execution : Terminate program execution with exception",
      "operandLayout": ""
    },
    {
      "name": "syscall",
      "format": "R",
      "description": "Issue a system call : Execute the system call specified by value in $v0",
      "operandLayout": ""
    },
    {
      "name": "j",
      "format": "J",
      "description": "Jump unconditionally : Jump to statement at target address",
      "operandLayout": "target"
    },
    {
      "name": "jr",
      "format": "R",
      "description": "Jump register unconditionally : Jump to statement whose address is in $t1",
      "operandLayout": "$t1"
    },
    {
      "name": "jal",
      "format": "J",
      "description": "Jump and link : Set $ra to Program Counter (return address) then jump to statement at target address",
      "operandLayout": "target"
    },
    {
      "name": "jalr",
      "format": "R",
      "description": "Jump and link register : Set $t1 to Program Counter (return address) then jump to statement whose address is in $t2",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "jalr",
      "format": "R",
      "description": "Jump and link register : Set $ra to Program Counter (return address) then jump to statement whose address is in $t1",
      "operandLayout": "$t1"
    },
    {
      "name": "lb",
      "format": "I",
      "description": "Load byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "lh",
      "format": "I",
      "description": "Load halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "lhu",
      "format": "I",
      "description": "Load halfword unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "lbu",
      "format": "I",
      "description": "Load byte unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "sb",
      "format": "I",
      "description": "Store byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "sh",
      "format": "I",
      "description": "Store halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,-100($t2)"
    },
    {
      "name": "clo",
      "format": "R",
      "description": "Count number of leading ones : Set $t1 to the count of leading one bits in $t2 starting at most significant bit position",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "clz",
      "format": "R",
      "description": "Count number of leading zeroes : Set $t1 to the count of leading zero bits in $t2 starting at most significant bit positio",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "mfc0",
      "format": "R",
      "description": "Move from Coprocessor 0 : Set $t1 to the value stored in Coprocessor 0 register $8",
      "operandLayout": "$t1,$8"
    },
    {
      "name": "mtc0",
      "format": "R",
      "description": "Move to Coprocessor 0 : Set Coprocessor 0 register $8 to value stored in $t1",
      "operandLayout": "$t1,$8"
    },
    {
      "name": "add.s",
      "format": "R",
      "description": "Floating point addition single precision : Set $f0 to single-precision floating point value of $f1 plus $f3",
      "operandLayout": "$f0,$f1,$f3"
    },
    {
      "name": "sub.s",
      "format": "R",
      "description": "Floating point subtraction single precision : Set $f0 to single-precision floating point value of $f1  minus $f3",
      "operandLayout": "$f0,$f1,$f3"
    },
    {
      "name": "mul.s",
      "format": "R",
      "description": "Floating point multiplication single precision : Set $f0 to single-precision floating point value of $f1 times $f3",
      "operandLayout": "$f0,$f1,$f3"
    },
    {
      "name": "div.s",
      "format": "R",
      "description": "Floating point division single precision : Set $f0 to single-precision floating point value of $f1 divided by $f3",
      "operandLayout": "$f0,$f1,$f3"
    },
    {
      "name": "sqrt.s",
      "format": "R",
      "description": "Square root single precision : Set $f0 to single-precision floating point square root of $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "floor.w.s",
      "format": "R",
      "description": "Floor single precision to word : Set $f0 to 32-bit integer floor of single-precision float in $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "ceil.w.s",
      "format": "R",
      "description": "Ceiling single precision to word : Set $f0 to 32-bit integer ceiling of single-precision float in $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "round.w.s",
      "format": "R",
      "description": "Round single precision to word : Set $f0 to 32-bit integer round of single-precision float in $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "trunc.w.s",
      "format": "R",
      "description": "Truncate single precision to word : Set $f0 to 32-bit integer truncation of single-precision float in $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "add.d",
      "format": "R",
      "description": "Floating point addition double precision : Set $f2 to double-precision floating point value of $f4 plus $f6",
      "operandLayout": "$f2,$f4,$f6"
    },
    {
      "name": "sub.d",
      "format": "R",
      "description": "Floating point subtraction double precision : Set $f2 to double-precision floating point value of $f4 minus $f6",
      "operandLayout": "$f2,$f4,$f6"
    },
    {
      "name": "mul.d",
      "format": "R",
      "description": "Floating point multiplication double precision : Set $f2 to double-precision floating point value of $f4 times $f6",
      "operandLayout": "$f2,$f4,$f6"
    },
    {
      "name": "div.d",
      "format": "R",
      "description": "Floating point division double precision : Set $f2 to double-precision floating point value of $f4 divided by $f6",
      "operandLayout": "$f2,$f4,$f6"
    },
    {
      "name": "sqrt.d",
      "format": "R",
      "description": "Square root double precision : Set $f2 to double-precision floating point square root of $f4",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "floor.w.d",
      "format": "R",
      "description": "Floor double precision to word : Set $f1 to 32-bit integer floor of double-precision float in $f2",
      "operandLayout": "$f1,$f2"
    },
    {
      "name": "ceil.w.d",
      "format": "R",
      "description": "Ceiling double precision to word : Set $f1 to 32-bit integer ceiling of double-precision float in $f2",
      "operandLayout": "$f1,$f2"
    },
    {
      "name": "round.w.d",
      "format": "R",
      "description": "Round double precision to word : Set $f1 to 32-bit integer round of double-precision float in $f2",
      "operandLayout": "$f1,$f2"
    },
    {
      "name": "trunc.w.d",
      "format": "R",
      "description": "Truncate double precision to word : Set $f1 to 32-bit integer truncation of double-precision float in $f2",
      "operandLayout": "$f1,$f2"
    },
    {
      "name": "bc1t",
      "format": "I-branch",
      "description": "Branch if FP condition flag 0 true (BC1T, not BCLT) : If Coprocessor 1 condition flag 0 is true (one) then branch to statement at label's address",
      "operandLayout": "label"
    },
    {
      "name": "bc1t",
      "format": "I-branch",
      "description": "Branch if specified FP condition flag true (BC1T, not BCLT) : If Coprocessor 1 condition flag specified by immediate is true (one) then branch to statement at label's address",
      "operandLayout": "1,label"
    },
    {
      "name": "bc1f",
      "format": "I-branch",
      "description": "Branch if FP condition flag 0 false (BC1F, not BCLF) : If Coprocessor 1 condition flag 0 is false (zero) then branch to statement at label's address",
      "operandLayout": "label"
    },
    {
      "name": "bc1f",
      "format": "I-branch",
      "description": "Branch if specified FP condition flag false (BC1F, not BCLF) : If Coprocessor 1 condition flag specified by immediate is false (zero) then branch to statement at label's address",
      "operandLayout": "1,label"
    },
    {
      "name": "c.eq.s",
      "format": "R",
      "description": "Compare equal single precision : If $f0 is equal to $f1, set Coprocessor 1 condition flag 0 true else set it false",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "c.eq.s",
      "format": "R",
      "description": "Compare equal single precision : If $f0 is equal to $f1, set Coprocessor 1 condition flag specied by immediate to true else set it to false",
      "operandLayout": "1,$f0,$f1"
    },
    {
      "name": "c.le.s",
      "format": "R",
      "description": "Compare less or equal single precision : If $f0 is less than or equal to $f1, set Coprocessor 1 condition flag 0 true else set it false",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "c.le.s",
      "format": "R",
      "description": "Compare less or equal single precision : If $f0 is less than or equal to $f1, set Coprocessor 1 condition flag specified by immediate to true else set it to false",
      "operandLayout": "1,$f0,$f1"
    },
    {
      "name": "c.lt.s",
      "format": "R",
      "description": "Compare less than single precision : If $f0 is less than $f1, set Coprocessor 1 condition flag 0 true else set it false",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "c.lt.s",
      "format": "R",
      "description": "Compare less than single precision : If $f0 is less than $f1, set Coprocessor 1 condition flag specified by immediate to true else set it to false",
      "operandLayout": "1,$f0,$f1"
    },
    {
      "name": "c.eq.d",
      "format": "R",
      "description": "Compare equal double precision : If $f2 is equal to $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "c.eq.d",
      "format": "R",
      "description": "Compare equal double precision : If $f2 is equal to $f4 (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false",
      "operandLayout": "1,$f2,$f4"
    },
    {
      "name": "c.le.d",
      "format": "R",
      "description": "Compare less or equal double precision : If $f2 is less than or equal to $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "c.le.d",
      "format": "R",
      "description": "Compare less or equal double precision : If $f2 is less than or equal to $f4 (double-precision), set Coprocessor 1 condition flag specfied by immediate true else set it false",
      "operandLayout": "1,$f2,$f4"
    },
    {
      "name": "c.lt.d",
      "format": "R",
      "description": "Compare less than double precision : If $f2 is less than $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "c.lt.d",
      "format": "R",
      "description": "Compare less than double precision : If $f2 is less than $f4 (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false",
      "operandLayout": "1,$f2,$f4"
    },
    {
      "name": "abs.s",
      "format": "R",
      "description": "Floating point absolute value single precision : Set $f0 to absolute value of $f1, single precision",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "abs.d",
      "format": "R",
      "description": "Floating point absolute value double precision : Set $f2 to absolute value of $f4, double precision",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "cvt.d.s",
      "format": "R",
      "description": "Convert from single precision to double precision : Set $f2 to double precision equivalent of single precision value in $f1",
      "operandLayout": "$f2,$f1"
    },
    {
      "name": "cvt.d.w",
      "format": "R",
      "description": "Convert from word to double precision : Set $f2 to double precision equivalent of 32-bit integer value in $f1",
      "operandLayout": "$f2,$f1"
    },
    {
      "name": "cvt.s.d",
      "format": "R",
      "description": "Convert from double precision to single precision : Set $f1 to single precision equivalent of double precision value in $f2",
      "operandLayout": "$f1,$f2"
    },
    {
      "name": "cvt.s.w",
      "format": "R",
      "description": "Convert from word to single precision : Set $f0 to single precision equivalent of 32-bit integer value in $f2",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "cvt.w.d",
      "format": "R",
      "description": "Convert from double precision to word : Set $f1 to 32-bit integer equivalent of double precision value in $f2",
      "operandLayout": "$f1,$f2"
    },
    {
      "name": "cvt.w.s",
      "format": "R",
      "description": "Convert from single precision to word : Set $f0 to 32-bit integer equivalent of single precision value in $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "mov.d",
      "format": "R",
      "description": "Move floating point double precision : Set double precision $f2 to double precision value in $f4",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "movf.d",
      "format": "R",
      "description": "Move floating point double precision : If condition flag 0 false, set double precision $f2 to double precision value in $f4",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "movf.d",
      "format": "R",
      "description": "Move floating point double precision : If condition flag specified by immediate is false, set double precision $f2 to double precision value in $f4",
      "operandLayout": "$f2,$f4,1"
    },
    {
      "name": "movt.d",
      "format": "R",
      "description": "Move floating point double precision : If condition flag 0 true, set double precision $f2 to double precision value in $f4",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "movt.d",
      "format": "R",
      "description": "Move floating point double precision : If condition flag specified by immediate is true, set double precision $f2 to double precision value in $f4e",
      "operandLayout": "$f2,$f4,1"
    },
    {
      "name": "movn.d",
      "format": "R",
      "description": "Move floating point double precision : If $t3 is not zero, set double precision $f2 to double precision value in $f4",
      "operandLayout": "$f2,$f4,$t3"
    },
    {
      "name": "movz.d",
      "format": "R",
      "description": "Move floating point double precision : If $t3 is zero, set double precision $f2 to double precision value in $f4",
      "operandLayout": "$f2,$f4,$t3"
    },
    {
      "name": "mov.s",
      "format": "R",
      "description": "Move floating point single precision : Set single precision $f0 to single precision value in $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "movf.s",
      "format": "R",
      "description": "Move floating point single precision : If condition flag 0 is false, set single precision $f0 to single precision value in $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "movf.s",
      "format": "R",
      "description": "Move floating point single precision : If condition flag specified by immediate is false, set single precision $f0 to single precision value in $f1e",
      "operandLayout": "$f0,$f1,1"
    },
    {
      "name": "movt.s",
      "format": "R",
      "description": "Move floating point single precision : If condition flag 0 is true, set single precision $f0 to single precision value in $f1e",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "movt.s",
      "format": "R",
      "description": "Move floating point single precision : If condition flag specified by immediate is true, set single precision $f0 to single precision value in $f1e",
      "operandLayout": "$f0,$f1,1"
    },
    {
      "name": "movn.s",
      "format": "R",
      "description": "Move floating point single precision : If $t3 is not zero, set single precision $f0 to single precision value in $f1",
      "operandLayout": "$f0,$f1,$t3"
    },
    {
      "name": "movz.s",
      "format": "R",
      "description": "Move floating point single precision : If $t3 is zero, set single precision $f0 to single precision value in $f1",
      "operandLayout": "$f0,$f1,$t3"
    },
    {
      "name": "mfc1",
      "format": "R",
      "description": "Move from Coprocessor 1 (FPU) : Set $t1 to value in Coprocessor 1 register $f1",
      "operandLayout": "$t1,$f1"
    },
    {
      "name": "mtc1",
      "format": "R",
      "description": "Move to Coprocessor 1 (FPU) : Set Coprocessor 1 register $f1 to value in $t1",
      "operandLayout": "$t1,$f1"
    },
    {
      "name": "neg.d",
      "format": "R",
      "description": "Floating point negate double precision : Set double precision $f2 to negation of double precision value in $f4",
      "operandLayout": "$f2,$f4"
    },
    {
      "name": "neg.s",
      "format": "R",
      "description": "Floating point negate single precision : Set single precision $f0 to negation of single precision value in $f1",
      "operandLayout": "$f0,$f1"
    },
    {
      "name": "lwc1",
      "format": "I",
      "description": "Load word into Coprocessor 1 (FPU) : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,-100($t2)"
    },
    {
      "name": "ldc1",
      "format": "I",
      "description": "Load double word Coprocessor 1 (FPU)) : Set $f2 to 64-bit value from effective memory doubleword address",
      "operandLayout": "$f2,-100($t2)"
    },
    {
      "name": "swc1",
      "format": "I",
      "description": "Store word from Coprocesor 1 (FPU) : Store 32 bit value in $f1 to effective memory word address",
      "operandLayout": "$f1,-100($t2)"
    },
    {
      "name": "sdc1",
      "format": "I",
      "description": "Store double word from Coprocessor 1 (FPU)) : Store 64 bit value in $f2 to effective memory doubleword address",
      "operandLayout": "$f2,-100($t2)"
    },
    {
      "name": "teq",
      "format": "R",
      "description": "Trap if equal : Trap if $t1 is equal to $t2",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "teqi",
      "format": "I",
      "description": "Trap if equal to immediate : Trap if $t1 is equal to sign-extended 16 bit immediate",
      "operandLayout": "$t1,-100"
    },
    {
      "name": "tne",
      "format": "R",
      "description": "Trap if not equal : Trap if $t1 is not equal to $t2",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "tnei",
      "format": "I",
      "description": "Trap if not equal to immediate : Trap if $t1 is not equal to sign-extended 16 bit immediate",
      "operandLayout": "$t1,-100"
    },
    {
      "name": "tge",
      "format": "R",
      "description": "Trap if greater or equal : Trap if $t1 is greater than or equal to $t2",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "tgeu",
      "format": "R",
      "description": "Trap if greater or equal unsigned : Trap if $t1 is greater than or equal to $t2 using unsigned comparision",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "tgei",
      "format": "I",
      "description": "Trap if greater than or equal to immediate : Trap if $t1 greater than or equal to sign-extended 16 bit immediate",
      "operandLayout": "$t1,-100"
    },
    {
      "name": "tgeiu",
      "format": "I",
      "description": "Trap if greater or equal to immediate unsigned : Trap if $t1 greater than or equal to sign-extended 16 bit immediate, unsigned comparison",
      "operandLayout": "$t1,-100"
    },
    {
      "name": "tlt",
      "format": "R",
      "description": "Trap if less than: Trap if $t1 less than $t2",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "tltu",
      "format": "R",
      "description": "Trap if less than unsigned : Trap if $t1 less than $t2, unsigned comparison",
      "operandLayout": "$t1,$t2"
    },
    {
      "name": "tlti",
      "format": "I",
      "description": "Trap if less than immediate : Trap if $t1 less than sign-extended 16-bit immediate",
      "operandLayout": "$t1,-100"
    },
    {
      "name": "tltiu",
      "format": "I",
      "description": "Trap if less than immediate unsigned : Trap if $t1 less than sign-extended 16-bit immediate, unsigned comparison",
      "operandLayout": "$t1,-100"
    },
    {
      "name": "eret",
      "format": "R",
      "description": "Exception return : Set Program Counter to Coprocessor 0 EPC register value, set Coprocessor Status register bit 1 (exception level) to zero",
      "operandLayout": ""
    }
  ],
  "pseudoinstructions": [
    {
      "name": "not",
      "format": "pseudo",
      "description": "Bitwise NOT (bit inversion)",
      "operandLayout": "$t1,$t2",
      "templates": [
        "nor RG1, RG2, $0"
      ]
    },
    {
      "name": "add",
      "format": "pseudo",
      "description": "ADDition : set $t1 to ($t2 plus 16-bit immediate)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi RG1, RG2, VL3"
      ]
    },
    {
      "name": "add",
      "format": "pseudo",
      "description": "ADDition : set $t1 to ($t2 plus 32-bit immediate)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "add RG1, RG2, $1"
      ]
    },
    {
      "name": "addu",
      "format": "pseudo",
      "description": "ADDition Unsigned : set $t1 to ($t2 plus 32-bit immediate), no overflow",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "addu RG1, RG2, $1"
      ]
    },
    {
      "name": "addi",
      "format": "pseudo",
      "description": "ADDition Immediate : set $t1 to ($t2 plus 32-bit immediate)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "add RG1, RG2, $1"
      ]
    },
    {
      "name": "addiu",
      "format": "pseudo",
      "description": "ADDition Immediate Unsigned: set $t1 to ($t2 plus 32-bit immediate), no overflow",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "addu RG1, RG2, $1"
      ]
    },
    {
      "name": "sub",
      "format": "pseudo",
      "description": "SUBtraction : set $t1 to ($t2 minus 16-bit immediate)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "sub RG1, RG2, $1"
      ]
    },
    {
      "name": "sub",
      "format": "pseudo",
      "description": "SUBtraction : set $t1 to ($t2 minus 32-bit immediate)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sub RG1, RG2, $1"
      ]
    },
    {
      "name": "subu",
      "format": "pseudo",
      "description": "SUBtraction Unsigned : set $t1 to ($t2 minus 32-bit immediate), no overflow",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "subu RG1, RG2, $1"
      ]
    },
    {
      "name": "subi",
      "format": "pseudo",
      "description": "SUBtraction Immediate : set $t1 to ($t2 minus 16-bit immediate)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "sub RG1, RG2, $1"
      ]
    },
    {
      "name": "subi",
      "format": "pseudo",
      "description": "SUBtraction Immediate : set $t1 to ($t2 minus 32-bit immediate)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sub RG1, RG2, $1"
      ]
    },
    {
      "name": "subiu",
      "format": "pseudo",
      "description": "SUBtraction Immediate Unsigned : set $t1 to ($t2 minus 32-bit immediate), no overflow",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "subu RG1, RG2, $1"
      ]
    },
    {
      "name": "andi",
      "format": "pseudo",
      "description": "AND Immediate : set $t1 to ($t2 bitwise-AND 32-bit immediate)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "and RG1, RG2, $1"
      ]
    },
    {
      "name": "ori",
      "format": "pseudo",
      "description": "OR Immediate : set $t1 to ($t2 bitwise-OR 32-bit immediate)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "or RG1, RG2, $1"
      ]
    },
    {
      "name": "xori",
      "format": "pseudo",
      "description": "XOR Immediate : set $t1 to ($t2 bitwise-exclusive-OR 32-bit immediate)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "xor RG1, RG2, $1"
      ]
    },
    {
      "name": "and",
      "format": "pseudo",
      "description": "AND : set $t1 to ($t2 bitwise-AND 16-bit unsigned immediate)",
      "operandLayout": "$t1,$t2,100",
      "templates": [
        "andi RG1, RG2, VL3U"
      ]
    },
    {
      "name": "or",
      "format": "pseudo",
      "description": "OR : set $t1 to ($t2 bitwise-OR 16-bit unsigned immediate)",
      "operandLayout": "$t1,$t2,100",
      "templates": [
        "ori RG1, RG2, VL3U"
      ]
    },
    {
      "name": "xor",
      "format": "pseudo",
      "description": "XOR : set $t1 to ($t2 bitwise-exclusive-OR 16-bit unsigned immediate)",
      "operandLayout": "$t1,$t2,100",
      "templates": [
        "xori RG1, RG2, VL3U"
      ]
    },
    {
      "name": "and",
      "format": "pseudo",
      "description": "AND : set $t1 to ($t1 bitwise-AND 16-bit unsigned immediate)",
      "operandLayout": "$t1,100",
      "templates": [
        "andi RG1, RG1, VL2U"
      ]
    },
    {
      "name": "or",
      "format": "pseudo",
      "description": "OR : set $t1 to ($t1 bitwise-OR 16-bit unsigned immediate)",
      "operandLayout": "$t1,100",
      "templates": [
        "ori RG1, RG1, VL2U"
      ]
    },
    {
      "name": "xor",
      "format": "pseudo",
      "description": "XOR : set $t1 to ($t1 bitwise-exclusive-OR 16-bit unsigned immediate)",
      "operandLayout": "$t1,100",
      "templates": [
        "xori RG1, RG1, VL2U"
      ]
    },
    {
      "name": "andi",
      "format": "pseudo",
      "description": "AND Immediate : set $t1 to ($t1 bitwise-AND 16-bit unsigned immediate)",
      "operandLayout": "$t1,100",
      "templates": [
        "andi RG1, RG1, VL2U"
      ]
    },
    {
      "name": "ori",
      "format": "pseudo",
      "description": "OR Immediate : set $t1 to ($t1 bitwise-OR 16-bit unsigned immediate)",
      "operandLayout": "$t1,100",
      "templates": [
        "ori RG1, RG1, VL2U"
      ]
    },
    {
      "name": "xori",
      "format": "pseudo",
      "description": "XOR Immediate : set $t1 to ($t1 bitwise-exclusive-OR 16-bit unsigned immediate)",
      "operandLayout": "$t1,100",
      "templates": [
        "xori RG1, RG1, VL2U"
      ]
    },
    {
      "name": "andi",
      "format": "pseudo",
      "description": "AND Immediate : set $t1 to ($t1 bitwise-AND 32-bit immediate)",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "and RG1, RG1, $1"
      ]
    },
    {
      "name": "ori",
      "format": "pseudo",
      "description": "OR Immediate : set $t1 to ($t1 bitwise-OR 32-bit immediate)",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "xori",
      "format": "pseudo",
      "description": "XOR Immediate : set $t1 to ($t1 bitwise-exclusive-OR 32-bit immediate)",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "xor RG1, RG1, $1"
      ]
    },
    {
      "name": "seq",
      "format": "pseudo",
      "description": "Set EQual : if $t2 equal to $t3 then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "subu RG1, RG2, RG3",
        "ori $1, $0, 1",
        "sltu RG1, RG1, $1"
      ]
    },
    {
      "name": "seq",
      "format": "pseudo",
      "description": "Set EQual : if $t2 equal to 16-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "subu RG1, RG2, $1",
        "ori $1, $0, 1",
        "sltu RG1, RG1, $1"
      ]
    },
    {
      "name": "seq",
      "format": "pseudo",
      "description": "Set EQual : if $t2 equal to 32-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "subu RG1, RG2, $1",
        "ori $1, $0, 1",
        "sltu RG1, RG1, $1"
      ]
    },
    {
      "name": "sne",
      "format": "pseudo",
      "description": "Set Not Equal : if $t2 not equal to $t3 then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "subu RG1, RG2, RG3",
        "sltu RG1, $0, RG1"
      ]
    },
    {
      "name": "sne",
      "format": "pseudo",
      "description": "Set Not Equal : if $t2 not equal to 16-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "subu RG1, RG2, $1",
        "sltu RG1, $0, RG1"
      ]
    },
    {
      "name": "sne",
      "format": "pseudo",
      "description": "Set Not Equal : if $t2 not equal to 32-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "subu RG1, RG2, $1",
        "sltu RG1, $0, RG1"
      ]
    },
    {
      "name": "sge",
      "format": "pseudo",
      "description": "Set Greater or Equal : if $t2 greater or equal to $t3 then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "slt RG1, RG2, RG3",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sge",
      "format": "pseudo",
      "description": "Set Greater or Equal : if $t2 greater or equal to 16-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "slt RG1, RG2, $1",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sge",
      "format": "pseudo",
      "description": "Set Greater or Equal : if $t2 greater or equal to 32-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "slt RG1, RG2, $1",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sgeu",
      "format": "pseudo",
      "description": "Set Greater or Equal Unsigned : if $t2 greater or equal to $t3 (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "sltu RG1, RG2, RG3",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sgeu",
      "format": "pseudo",
      "description": "Set Greater or Equal Unsigned : if $t2 greater or equal to 16-bit immediate (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "sltu RG1, RG2, $1",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sgeu",
      "format": "pseudo",
      "description": "Set Greater or Equal Unsigned : if $t2 greater or equal to 32-bit immediate (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sltu RG1, RG2, $1",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sgt",
      "format": "pseudo",
      "description": "Set Greater Than : if $t2 greater than $t3 then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "slt RG1, RG3, RG2"
      ]
    },
    {
      "name": "sgt",
      "format": "pseudo",
      "description": "Set Greater Than : if $t2 greater than 16-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "slt RG1, $1, RG2"
      ]
    },
    {
      "name": "sgt",
      "format": "pseudo",
      "description": "Set Greater Than : if $t2 greater than 32-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "slt RG1, $1, RG2"
      ]
    },
    {
      "name": "sgtu",
      "format": "pseudo",
      "description": "Set Greater Than Unsigned : if $t2 greater than $t3 (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "sltu RG1, RG3, RG2"
      ]
    },
    {
      "name": "sgtu",
      "format": "pseudo",
      "description": "Set Greater Than Unsigned : if $t2 greater than 16-bit immediate (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "sltu RG1, $1, RG2"
      ]
    },
    {
      "name": "sgtu",
      "format": "pseudo",
      "description": "Set Greater Than Unsigned : if $t2 greater than 32-bit immediate (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sltu RG1, $1, RG2"
      ]
    },
    {
      "name": "sle",
      "format": "pseudo",
      "description": "Set Less or Equal : if $t2 less or equal to $t3 then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "slt RG1, RG3, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sle",
      "format": "pseudo",
      "description": "Set Less or Equal : if $t2 less or equal to 16-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "slt RG1, $1, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sle",
      "format": "pseudo",
      "description": "Set Less or Equal : if $t2 less or equal to 32-bit immediate then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "slt RG1, $1, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sleu",
      "format": "pseudo",
      "description": "Set Less or Equal Unsigned: if $t2 less or equal to $t3 (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "sltu RG1, RG3, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sleu",
      "format": "pseudo",
      "description": "Set Less or Equal Unsigned: if $t2 less or equal to 16-bit immediate (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "sltu RG1, $1, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "sleu",
      "format": "pseudo",
      "description": "Set Less or Equal Unsigned: if $t2 less or equal to 32-bit immediate (unsigned compare) then set $t1 to 1 else 0",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "sltu RG1, $1, RG2",
        "ori $1, $0, 1",
        "subu RG1, $1, RG1"
      ]
    },
    {
      "name": "move",
      "format": "pseudo",
      "description": "MOVE : Set $t1 to contents of $t2",
      "operandLayout": "$t1,$t2",
      "templates": [
        "addu RG1, $0, RG2"
      ]
    },
    {
      "name": "abs",
      "format": "pseudo",
      "description": "ABSolute value : Set $t1 to absolute value of $t2 (algorithm from Hacker's Delight)",
      "operandLayout": "$t1,$t2",
      "templates": [
        "sra $1, RG2, 31",
        "xor RG1, $1, RG2",
        "subu RG1, RG1, $1"
      ]
    },
    {
      "name": "neg",
      "format": "pseudo",
      "description": "NEGate : Set $t1 to negation of $t2",
      "operandLayout": "$t1,$t2",
      "templates": [
        "sub RG1, $0, RG2"
      ]
    },
    {
      "name": "negu",
      "format": "pseudo",
      "description": "NEGate Unsigned : Set $t1 to negation of $t2, no overflow",
      "operandLayout": "$t1,$t2",
      "templates": [
        "subu RG1, $0, RG2"
      ]
    },
    {
      "name": "b",
      "format": "pseudo",
      "description": "Branch : Branch to statement at label unconditionally",
      "operandLayout": "label",
      "templates": [
        "bgez $0, LAB"
      ]
    },
    {
      "name": "beqz",
      "format": "pseudo",
      "description": "Branch if EQual Zero : Branch to statement at label if $t1 is equal to zero",
      "operandLayout": "$t1,label",
      "templates": [
        "beq RG1, $0, LAB"
      ]
    },
    {
      "name": "bnez",
      "format": "pseudo",
      "description": "Branch if Not Equal Zero : Branch to statement at label if $t1 is not equal to zero",
      "operandLayout": "$t1,label",
      "templates": [
        "bne RG1, $0, LAB"
      ]
    },
    {
      "name": "beq",
      "format": "pseudo",
      "description": "Branch if EQual : Branch to statement at label if $t1 is equal to 16-bit immediate",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "addi $1, $0, VL2",
        "beq $1, RG1, LAB"
      ]
    },
    {
      "name": "beq",
      "format": "pseudo",
      "description": "Branch if EQual : Branch to statement at label if $t1 is equal to 32-bit immediate",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "beq $1, RG1, LAB"
      ]
    },
    {
      "name": "bne",
      "format": "pseudo",
      "description": "Branch if Not Equal : Branch to statement at label if $t1 is not equal to 16-bit immediate",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "addi $1, $0, VL2",
        "bne $1, RG1, LAB"
      ]
    },
    {
      "name": "bne",
      "format": "pseudo",
      "description": "Branch if Not Equal : Branch to statement at label if $t1 is not equal to 32-bit immediate",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "bne $1, RG1, LAB"
      ]
    },
    {
      "name": "bge",
      "format": "pseudo",
      "description": "Branch if Greater or Equal : Branch to statement at label if $t1 is greater or equal to $t2",
      "operandLayout": "$t1,$t2,label",
      "templates": [
        "slt $1, RG1, RG2",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bge",
      "format": "pseudo",
      "description": "Branch if Greater or Equal : Branch to statement at label if $t1 is greater or equal to 16-bit immediate",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "slti $1, RG1, VL2",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bge",
      "format": "pseudo",
      "description": "Branch if Greater or Equal : Branch to statement at label if $t1 is greater or equal to 32-bit immediate",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "slt $1, RG1, $1",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bgeu",
      "format": "pseudo",
      "description": "Branch if Greater or Equal Unsigned : Branch to statement at label if $t1 is greater or equal to $t2 (unsigned compare)",
      "operandLayout": "$t1,$t2,label",
      "templates": [
        "sltu $1, RG1, RG2",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bgeu",
      "format": "pseudo",
      "description": "Branch if Greater or Equal Unsigned : Branch to statement at label if $t1 is greater or equal to 16-bit immediate (unsigned compare)",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "sltiu $1, RG1, VL2",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bgeu",
      "format": "pseudo",
      "description": "Branch if Greater or Equal Unsigned : Branch to statement at label if $t1 is greater or equal to 32-bit immediate (unsigned compare)",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "sltu $1, RG1, $1",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bgt",
      "format": "pseudo",
      "description": "Branch if Greater Than : Branch to statement at label if $t1 is greater than $t2",
      "operandLayout": "$t1,$t2,label",
      "templates": [
        "slt $1, RG2, RG1",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "bgt",
      "format": "pseudo",
      "description": "Branch if Greater Than : Branch to statement at label if $t1 is greater than 16-bit immediate",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "addi $1, $0, VL2",
        "slt $1, $1, RG1",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "bgt",
      "format": "pseudo",
      "description": "Branch if Greater Than : Branch to statement at label if $t1 is greater than 32-bit immediate",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2P1",
        "ori $1, $1, VL2P1U",
        "slt $1, RG1, $1",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bgtu",
      "format": "pseudo",
      "description": "Branch if Greater Than Unsigned: Branch to statement at label if $t1 is greater than $t2 (unsigned compare)",
      "operandLayout": "$t1,$t2,label",
      "templates": [
        "sltu $1, RG2, RG1",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "bgtu",
      "format": "pseudo",
      "description": "Branch if Greater Than Unsigned: Branch to statement at label if $t1 is greater than 16-bit immediate (unsigned compare)",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "addi $1, $0, VL2",
        "sltu $1, $1, RG1",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "bgtu",
      "format": "pseudo",
      "description": "Branch if Greater Than Unsigned: Branch to statement at label if $t1 is greater than 16-bit immediate (unsigned compare)",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "sltu $1, $1, RG1",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "ble",
      "format": "pseudo",
      "description": "Branch if Less or Equal : Branch to statement at label if $t1 is less than or equal to $t2",
      "operandLayout": "$t1,$t2,label",
      "templates": [
        "slt $1, RG2, RG1",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "ble",
      "format": "pseudo",
      "description": "Branch if Less or Equal : Branch to statement at label if $t1 is less than or equal to 16-bit immediate",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "addi $1, RG1, -1",
        "slti $1, $1, VL2",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "ble",
      "format": "pseudo",
      "description": "Branch if Less or Equal : Branch to statement at label if $t1 is less than or equal to 32-bit immediate",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2P1",
        "ori $1, $1, VL2P1U",
        "slt $1, RG1, $1",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "bleu",
      "format": "pseudo",
      "description": "Branch if Less or Equal Unsigned : Branch to statement at label if $t1 is less than or equal to $t2 (unsigned compare)",
      "operandLayout": "$t1,$t2,label",
      "templates": [
        "sltu $1, RG2, RG1",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bleu",
      "format": "pseudo",
      "description": "Branch if Less or Equal Unsigned : Branch to statement at label if $t1 is less than or equal to 16-bit immediate (unsigned compare)",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "addi $1, $0, VL2",
        "sltu $1, $1, RG1",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "bleu",
      "format": "pseudo",
      "description": "Branch if Less or Equal Unsigned : Branch to statement at label if $t1 is less than or equal to 32-bit immediate (unsigned compare)",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "sltu $1, $1, RG1",
        "beq $1, $0, LAB"
      ]
    },
    {
      "name": "blt",
      "format": "pseudo",
      "description": "Branch if Less Than : Branch to statement at label if $t1 is less than $t2",
      "operandLayout": "$t1,$t2,label",
      "templates": [
        "slt $1, RG1, RG2",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "blt",
      "format": "pseudo",
      "description": "Branch if Less Than : Branch to statement at label if $t1 is less than 16-bit immediate",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "slti $1, RG1, VL2",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "blt",
      "format": "pseudo",
      "description": "Branch if Less Than : Branch to statement at label if $t1 is less than 32-bit immediate",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "slt $1, RG1, $1",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "bltu",
      "format": "pseudo",
      "description": "Branch if Less Than Unsigned : Branch to statement at label if $t1 is less than $t2",
      "operandLayout": "$t1,$t2,label",
      "templates": [
        "sltu $1, RG1, RG2",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "bltu",
      "format": "pseudo",
      "description": "Branch if Less Than Unsigned : Branch to statement at label if $t1 is less than 16-bit immediate",
      "operandLayout": "$t1,-100,label",
      "templates": [
        "sltiu $1, RG1, VL2",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "bltu",
      "format": "pseudo",
      "description": "Branch if Less Than Unsigned : Branch to statement at label if $t1 is less than 32-bit immediate",
      "operandLayout": "$t1,100000,label",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "sltu $1, RG1, $1",
        "bne $1, $0, LAB"
      ]
    },
    {
      "name": "rol",
      "format": "pseudo",
      "description": "ROtate Left : Set $t1 to ($t2 rotated left by number of bit positions specified in $t3)",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "subu $1, $0, RG3",
        "srlv $1, RG2, $1",
        "sllv RG1, RG2, RG3",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "rol",
      "format": "pseudo",
      "description": "ROtate Left : Set $t1 to ($t2 rotated left by number of bit positions specified in 5-bit immediate)",
      "operandLayout": "$t1,$t2,10",
      "templates": [
        "srl $1, RG2, S32",
        "sll RG1, RG2, OP3",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ror",
      "format": "pseudo",
      "description": "ROtate Right : Set $t1 to ($t2 rotated right by number of bit positions specified in $t3)",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "subu $1, $0, RG3",
        "sllv $1, RG2, $1",
        "srlv RG1, RG2, RG3",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ror",
      "format": "pseudo",
      "description": "ROtate Right : Set $t1 to ($t2 rotated right by number of bit positions specified in 5-bit immediate)",
      "operandLayout": "$t1,$t2,10",
      "templates": [
        "sll $1, RG2, S32",
        "srl RG1, RG2, OP3",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "mfc1.d",
      "format": "pseudo",
      "description": "Move From Coprocessor 1 Double : Set $t1 to contents of $f2, set next higher register from $t1 to contents of next higher register from $f2",
      "operandLayout": "$t1,$f2",
      "templates": [
        "mfc1 RG1, RG2",
        "mfc1 NR1, NR2"
      ]
    },
    {
      "name": "mtc1.d",
      "format": "pseudo",
      "description": "Move To Coprocessor 1 Double : Set $f2 to contents of $t1, set next higher register from $f2 to contents of next higher register from $t1",
      "operandLayout": "$t1,$f2",
      "templates": [
        "mtc1 RG1, RG2",
        "mtc1 NR1, NR2"
      ]
    },
    {
      "name": "mul",
      "format": "pseudo",
      "description": "MULtiplication : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and 16-bit signed immediate (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "mul RG1, RG2, $1"
      ]
    },
    {
      "name": "mul",
      "format": "pseudo",
      "description": "MULtiplication : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and 32-bit immediate (use mfhi to access HI, mflo to access LO)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "mul RG1, RG2, $1"
      ]
    },
    {
      "name": "mulu",
      "format": "pseudo",
      "description": "MULtiplication Unsigned : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of ($t2 multiplied by $t3, unsigned multiplication)",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "multu RG2, RG3",
        "mflo RG1"
      ]
    },
    {
      "name": "mulu",
      "format": "pseudo",
      "description": "MULtiplication Unsigned :  Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of ($t2 multiplied by 16-bit immediate, unsigned multiplication)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "multu RG2, $1",
        "mflo RG1"
      ]
    },
    {
      "name": "mulu",
      "format": "pseudo",
      "description": "MULtiplication Unsigned :  Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of ($t2 multiplied by 32-bit immediate, unsigned multiplication)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "multu RG2, $1",
        "mflo RG1"
      ]
    },
    {
      "name": "mulo",
      "format": "pseudo",
      "description": "MULtiplication with Overflow : Set $t1 to low-order 32 bits of the product of $t2 and $t3",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "mult RG2, RG3",
        "mfhi $1",
        "mflo RG1",
        "sra RG1, RG1, 31",
        "beq $1, RG1, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ]
    },
    {
      "name": "mulo",
      "format": "pseudo",
      "description": "MULtiplication with Overflow : Set $t1 to low-order 32 bits of the product of $t2 and signed 16-bit immediate",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "mult RG2, $1",
        "mfhi $1",
        "mflo RG1",
        "sra RG1, RG1, 31",
        "beq $1, RG1, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ]
    },
    {
      "name": "mulo",
      "format": "pseudo",
      "description": "MULtiplication with Overflow : Set $t1 to low-order 32 bits of the product of $t2 and 32-bit immediate",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "mult RG2, $1",
        "mfhi $1",
        "mflo RG1",
        "sra RG1, RG1, 31",
        "beq $1, RG1, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ]
    },
    {
      "name": "mulou",
      "format": "pseudo",
      "description": "MULtiplication with Overflow Unsigned : Set $t1 to low-order 32 bits of the product of $t2 and $t3",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "multu RG2, RG3",
        "mfhi $1",
        "beq $1,$0, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ]
    },
    {
      "name": "mulou",
      "format": "pseudo",
      "description": "MULtiplication with Overflow Unsigned : Set $t1 to low-order 32 bits of the product of $t2 and signed 16-bit immediate",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "multu RG2, $1",
        "mfhi $1",
        "beq $1,$0, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ]
    },
    {
      "name": "mulou",
      "format": "pseudo",
      "description": "MULtiplication with Overflow Unsigned : Set $t1 to low-order 32 bits of the product of $t2 and 32-bit immediate",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "multu RG2, $1",
        "mfhi $1",
        "beq $1,$0, BROFF12",
        "DBNOP",
        "break",
        "mflo RG1"
      ]
    },
    {
      "name": "div",
      "format": "pseudo",
      "description": "DIVision : Set $t1 to ($t2 divided by $t3, integer division)",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "bne RG3, $0, BROFF12",
        "DBNOP",
        "break",
        "div RG2, RG3",
        "mflo RG1"
      ]
    },
    {
      "name": "div",
      "format": "pseudo",
      "description": "DIVision : Set $t1 to ($t2 divided by 16-bit immediate, integer division)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "div RG2, $1",
        "mflo RG1"
      ]
    },
    {
      "name": "div",
      "format": "pseudo",
      "description": "DIVision : Set $t1 to ($t2 divided by 32-bit immediate, integer division)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "div RG2, $1",
        "mflo RG1"
      ]
    },
    {
      "name": "divu",
      "format": "pseudo",
      "description": "DIVision Unsigned :  Set $t1 to ($t2 divided by $t3, unsigned integer division)",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "bne RG3, $0, BROFF12",
        "DBNOP",
        "break",
        "divu RG2, RG3",
        "mflo RG1"
      ]
    },
    {
      "name": "divu",
      "format": "pseudo",
      "description": "DIVision Unsigned :  Set $t1 to ($t2 divided by 16-bit immediate, unsigned integer division)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "divu RG2, $1",
        "mflo RG1"
      ]
    },
    {
      "name": "divu",
      "format": "pseudo",
      "description": "DIVision Unsigned :  Set $t1 to ($t2 divided by 32-bit immediate, unsigned integer division)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "divu RG2, $1",
        "mflo RG1"
      ]
    },
    {
      "name": "rem",
      "format": "pseudo",
      "description": "REMainder : Set $t1 to (remainder of $t2 divided by $t3)",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "bne RG3, $0, BROFF12",
        "DBNOP",
        "break",
        "div RG2, RG3",
        "mfhi RG1"
      ]
    },
    {
      "name": "rem",
      "format": "pseudo",
      "description": "REMainder : Set $t1 to (remainder of $t2 divided by 16-bit immediate)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "div RG2, $1",
        "mfhi RG1"
      ]
    },
    {
      "name": "rem",
      "format": "pseudo",
      "description": "REMainder : Set $t1 to (remainder of $t2 divided by 32-bit immediate)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "div RG2, $1",
        "mfhi RG1"
      ]
    },
    {
      "name": "remu",
      "format": "pseudo",
      "description": "REMainder : Set $t1 to (remainder of $t2 divided by $t3, unsigned division)",
      "operandLayout": "$t1,$t2,$t3",
      "templates": [
        "bne RG3, $0, BROFF12",
        "DBNOP",
        "break",
        "divu RG2, RG3",
        "mfhi RG1"
      ]
    },
    {
      "name": "remu",
      "format": "pseudo",
      "description": "REMainder : Set $t1 to (remainder of $t2 divided by 16-bit immediate, unsigned division)",
      "operandLayout": "$t1,$t2,-100",
      "templates": [
        "addi $1, $0, VL3",
        "divu RG2, $1",
        "mfhi RG1"
      ]
    },
    {
      "name": "remu",
      "format": "pseudo",
      "description": "REMainder : Set $t1 to (remainder of $t2 divided by 32-bit immediate, unsigned division)",
      "operandLayout": "$t1,$t2,100000",
      "templates": [
        "lui $1, VHL3",
        "ori $1, $1, VL3U",
        "divu RG2, $1",
        "mfhi RG1"
      ]
    },
    {
      "name": "li",
      "format": "pseudo",
      "description": "Load Immediate : Set $t1 to 16-bit immediate (sign-extended)",
      "operandLayout": "$t1,-100",
      "templates": [
        "addiu RG1, $0, VL2"
      ]
    },
    {
      "name": "li",
      "format": "pseudo",
      "description": "Load Immediate : Set $t1 to unsigned 16-bit immediate (zero-extended)",
      "operandLayout": "$t1,100",
      "templates": [
        "ori RG1, $0, VL2U"
      ]
    },
    {
      "name": "li",
      "format": "pseudo",
      "description": "Load Immediate : Set $t1 to 32-bit immediate",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VHL2",
        "ori RG1, $1, VL2U"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to contents of $t2",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "addi RG1, RG3, 0"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to 16-bit immediate (sign-extended)",
      "operandLayout": "$t1,-100",
      "templates": [
        "addiu RG1, $0, VL2"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to 16-bit immediate (zero-extended)",
      "operandLayout": "$t1,100",
      "templates": [
        "ori RG1, $0, VL2U"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to 32-bit immediate",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VHL2",
        "ori RG1, $1, VL2U"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to sum (of $t2 and 16-bit immediate)",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "add RG1, RG4, $1"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to sum (of $t2 and 32-bit immediate)",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VHL2",
        "ori $1, $1, VL2U",
        "add RG1, RG4, $1"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to label's address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LHL",
        "ori RG1, $1, LL2U",
        "COMPACT",
        "addi RG1, $0, LL2"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to sum (of $t2 and label's address)",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LHL",
        "ori $1, $1, LL2U",
        "add RG1, RG4, $1",
        "COMPACT",
        "addi RG1, RG4, LL2"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to sum (of label's address and 32-bit immediate)",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPN",
        "ori RG1, $1, LLPU"
      ]
    },
    {
      "name": "la",
      "format": "pseudo",
      "description": "Load Address : Set $t1 to sum (of label's address, 32-bit immediate, and $t2)",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPN",
        "ori $1, $1, LLPU",
        "add RG1, RG6, $1"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lw RG1,0(RG3)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,-100",
      "templates": [
        "lw RG1, VL2($0)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "lw RG1, 0($1)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "lw RG1,VL2($1)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lw RG1, 0($1)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lw RG1, VL2($1)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of memory word at label's address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "lw RG1, LL2($1)",
        "COMPACT",
        "lw RG1, LL2($0)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lw RG1, LL2($1)",
        "COMPACT",
        "lw RG1, LL2(RG4)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lw RG1, LLP($1)"
      ]
    },
    {
      "name": "lw",
      "format": "pseudo",
      "description": "Load Word : Set $t1 to contents of effective memory word address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lw RG1, LLP($1)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "sw RG1,0(RG3)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,-100",
      "templates": [
        "sw RG1, VL2($0)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "sw RG1, 0($1)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "sw RG1,VL2($1)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "sw RG1, 0($1)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sw RG1, VL2($1)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into memory word at label's address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "sw RG1, LL2($1)",
        "COMPACT",
        "sw RG1, LL2($0)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sw RG1, LL2($1)",
        "COMPACT",
        "sw RG1, LL2(RG4)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "sw RG1, LLP($1)"
      ]
    },
    {
      "name": "sw",
      "format": "pseudo",
      "description": "Store Word : Store $t1 contents into effective memory word address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sw RG1, LLP($1)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lh RG1,0(RG3)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,-100",
      "templates": [
        "lh RG1, VL2($0)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "lh RG1, 0($1)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "lh RG1,VL2($1)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lh RG1, 0($1)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lh RG1, VL2($1)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "lh RG1, LL2($1)",
        "COMPACT",
        "lh RG1, LL2($0)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lh RG1, LL2($1)",
        "COMPACT",
        "lh RG1, LL2(RG4)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lh RG1, LLP($1)"
      ]
    },
    {
      "name": "lh",
      "format": "pseudo",
      "description": "Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lh RG1, LLP($1)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "sh RG1,0(RG3)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,-100",
      "templates": [
        "sh RG1, VL2($0)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "sh RG1, 0($1)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "sh RG1,VL2($1)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "sh RG1, 0($1)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sh RG1, VL2($1)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "sh RG1, LL2($1)",
        "COMPACT",
        "sh RG1, LL2($0)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sh RG1, LL2($1)",
        "COMPACT",
        "sh RG1, LL2(RG4)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "sh RG1, LLP($1)"
      ]
    },
    {
      "name": "sh",
      "format": "pseudo",
      "description": "Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sh RG1, LLP($1)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lb RG1,0(RG3)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,-100",
      "templates": [
        "lb RG1, VL2($0)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "lb RG1, 0($1)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "lb RG1,VL2($1)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lb RG1, 0($1)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lb RG1, VL2($1)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "lb RG1, LL2($1)",
        "COMPACT",
        "lb RG1, LL2($0)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lb RG1, LL2($1)",
        "COMPACT",
        "lb RG1, LL2(RG4)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lb RG1, LLP($1)"
      ]
    },
    {
      "name": "lb",
      "format": "pseudo",
      "description": "Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lb RG1, LLP($1)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "sb RG1,0(RG3)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,-100",
      "templates": [
        "sb RG1, VL2($0)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "sb RG1, 0($1)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "sb RG1,VL2($1)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "sb RG1, 0($1)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sb RG1, VL2($1)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "sb RG1, LL2($1)",
        "COMPACT",
        "sb RG1, LL2($0)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sb RG1, LL2($1)",
        "COMPACT",
        "sb RG1, LL2(RG4)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "sb RG1, LLP($1)"
      ]
    },
    {
      "name": "sb",
      "format": "pseudo",
      "description": "Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sb RG1, LLP($1)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lhu RG1,0(RG3)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,-100",
      "templates": [
        "lhu RG1,VL2($0)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "lhu RG1, 0($1)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "lhu RG1,VL2($1)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lhu RG1, 0($1)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lhu RG1, VL2($1)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "lhu RG1, LL2($1)",
        "COMPACT",
        "lhu RG1, LL2($0)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lhu RG1, LL2($1)",
        "COMPACT",
        "lhu RG1, LL2(RG4)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lhu RG1, LLP($1)"
      ]
    },
    {
      "name": "lhu",
      "format": "pseudo",
      "description": "Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lhu RG1, LLP($1)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lbu RG1,0(RG3)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,-100",
      "templates": [
        "lbu RG1,VL2($0)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "lbu RG1, 0($1)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "lbu RG1,VL2($1)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lbu RG1, 0($1)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lbu RG1, VL2($1)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "lbu RG1, LL2($1)",
        "COMPACT",
        "lbu RG1, LL2($0)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lbu RG1, LL2($1)",
        "COMPACT",
        "lbu RG1, LL2(RG4)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lbu RG1, LLP($1)"
      ]
    },
    {
      "name": "lbu",
      "format": "pseudo",
      "description": "Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lbu RG1, LLP($1)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lwl RG1,0(RG3)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,-100",
      "templates": [
        "lwl RG1,VL2($0)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "lwl RG1, 0($1)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "lwl RG1,VL2($1)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lwl RG1, 0($1)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwl RG1, VL2($1)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "lwl RG1, LL2($1)",
        "COMPACT",
        "lwl RG1, LL2($0)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwl RG1, LL2($1)",
        "COMPACT",
        "lwl RG1, LL2(RG4)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lwl RG1, LLP($1)"
      ]
    },
    {
      "name": "lwl",
      "format": "pseudo",
      "description": "Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwl RG1, LLP($1)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "swl RG1,0(RG3)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,-100",
      "templates": [
        "swl RG1,VL2($0)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "swl RG1, 0($1)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "swl RG1,VL2($1)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "swl RG1, 0($1)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swl RG1, VL2($1)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "swl RG1, LL2($1)",
        "COMPACT",
        "swl RG1, LL2($0)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swl RG1, LL2($1)",
        "COMPACT",
        "swl RG1, LL2(RG4)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "swl RG1, LLP($1)"
      ]
    },
    {
      "name": "swl",
      "format": "pseudo",
      "description": "Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swl RG1, LLP($1)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lwr RG1,0(RG3)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,-100",
      "templates": [
        "lwr RG1,VL2($0)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "lwr RG1, 0($1)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "lwr RG1,VL2($1)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "lwr RG1, 0($1)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwr RG1, VL2($1)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "lwr RG1, LL2($1)",
        "COMPACT",
        "lwr RG1, LL2($0)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwr RG1, LL2($1)",
        "COMPACT",
        "lwr RG1, LL2(RG4)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lwr RG1, LLP($1)"
      ]
    },
    {
      "name": "lwr",
      "format": "pseudo",
      "description": "Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwr RG1, LLP($1)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "swr RG1,0(RG3)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,-100",
      "templates": [
        "swr RG1,VL2($0)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "swr RG1, 0"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "swr RG1,VL2($1)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "swr RG1, 0($1)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swr RG1, VL2($1)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "swr RG1, LL2($1)",
        "COMPACT",
        "swr RG1, LL2($0)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swr RG1, LL2($1)",
        "COMPACT",
        "swr RG1, LL2(RG4)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "swr RG1, LLP($1)"
      ]
    },
    {
      "name": "swr",
      "format": "pseudo",
      "description": "Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swr RG1, LLP($1)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "ll RG1,0(RG3)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,-100",
      "templates": [
        "ll RG1,VL2($0)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "ll RG1, 0($1)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "ll RG1,VL2($1)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "ll RG1, 0($1)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "ll RG1, VL2($1)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "ll RG1, LL2($1)",
        "COMPACT",
        "ll RG1, LL2($0)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "ll RG1, LL2($1)",
        "COMPACT",
        "ll RG1, LL2(RG4)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "ll RG1, LLP($1)"
      ]
    },
    {
      "name": "ll",
      "format": "pseudo",
      "description": "Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "ll RG1, LLP($1)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "sc RG1,0(RG3)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,-100",
      "templates": [
        "sc RG1,VL2($0)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,100",
      "templates": [
        "ori $1, $0, VL2U",
        "sc RG1, 0($1)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "sc RG1,VL2($1)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,100($t2)",
      "templates": [
        "ori $1, $0, VL2U",
        "addu $1, $1, RG4",
        "sc RG1, 0($1)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sc RG1, VL2($1)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "sc RG1, LL2($1)",
        "COMPACT",
        "sc RG1, LL2($0)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sc RG1, LL2($1)",
        "COMPACT",
        "sc RG1, LL2(RG4)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "sc RG1, LLP($1)"
      ]
    },
    {
      "name": "sc",
      "format": "pseudo",
      "description": "Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sc RG1, LLP($1)"
      ]
    },
    {
      "name": "ulw",
      "format": "pseudo",
      "description": "Unaligned Load Word : Set $t1 to the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,-100($t2)",
      "templates": [
        "lui $1, VH2P3",
        "addu $1, $1, RG4",
        "lwl RG1, VL2P3($1)",
        "lwr RG1, VL2(RG4)"
      ]
    },
    {
      "name": "ulh",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address",
      "operandLayout": "$t1,-100($t2)",
      "templates": [
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "lb RG1, VL2P1($1)",
        "lbu $1, VL2(RG4)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulhu",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address",
      "operandLayout": "$t1,-100($t2)",
      "templates": [
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "lbu RG1, VL2P1($1)",
        "lbu $1, VL2(RG4)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ld",
      "format": "pseudo",
      "description": "Load Doubleword : Set $t1 and the next register to the 64 bits starting at effective memory byte address",
      "operandLayout": "$t1,-100($t2)",
      "templates": [
        "lw RG1, VL2(RG4)",
        "lui $1, VH2P4",
        "addu $1, $1, RG4",
        "lw NR1, VL2P4($1)"
      ]
    },
    {
      "name": "usw",
      "format": "pseudo",
      "description": "Unaligned Store Word : Store $t1 contents into the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,-100($t2)",
      "templates": [
        "lui $1, VH2P3",
        "addu $1, $1, RG4",
        "swl RG1, VL2P3($1)",
        "swr RG1, VL2(RG4)"
      ]
    },
    {
      "name": "ush",
      "format": "pseudo",
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address",
      "operandLayout": "$t1,-100($t2)",
      "templates": [
        "sb RG1, VL2(RG4)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "sb RG1, VL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "sd",
      "format": "pseudo",
      "description": "Store Doubleword : Store contents of $t1 and the next register to the 64 bits starting at effective memory byte address",
      "operandLayout": "$t1,-100($t2)",
      "templates": [
        "sw RG1, VL2(RG4)",
        "lui $1, VH2P4",
        "addu $1, $1, RG4",
        "sw NR1, VL2P4($1)"
      ]
    },
    {
      "name": "ulw",
      "format": "pseudo",
      "description": "Unaligned Load Word : Set $t1 to the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2P3",
        "lwl RG1, VL2P3($1)",
        "lui $1, VH2",
        "lwr RG1, VL2($1)"
      ]
    },
    {
      "name": "ulw",
      "format": "pseudo",
      "description": "Unaligned Load Word : Set $t1 to the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2P3",
        "lwl RG1, LL2P3($1)",
        "lui $1, LH2",
        "lwr RG1, LL2($1)"
      ]
    },
    {
      "name": "ulw",
      "format": "pseudo",
      "description": "Unaligned Load Word : Set $t1 to the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPAP3",
        "lwl RG1, LLPP3($1)",
        "lui $1, LHPA",
        "lwr RG1, LLP($1)"
      ]
    },
    {
      "name": "ulw",
      "format": "pseudo",
      "description": "Unaligned Load Word : Set $t1 to the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lwl RG1, 3(RG3)",
        "lwr RG1, 0(RG3)"
      ]
    },
    {
      "name": "ulw",
      "format": "pseudo",
      "description": "Unaligned Load Word : Set $t1 to the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2P3",
        "addu $1, $1, RG4",
        "lwl RG1, VL2P3($1)",
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwr RG1, VL2($1)"
      ]
    },
    {
      "name": "ulw",
      "format": "pseudo",
      "description": "Unaligned Load Word : Set $t1 to the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2P3",
        "addu $1, $1, RG4",
        "lwl RG1, LL2P3($1)",
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwr RG1, LL2($1)"
      ]
    },
    {
      "name": "ulw",
      "format": "pseudo",
      "description": "Unaligned Load Word : Set $t1 to the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPAP3",
        "addu $1, $1, RG6",
        "lwl RG1, LLPP3($1)",
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwr RG1, LLP($1)"
      ]
    },
    {
      "name": "ulh",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2P1",
        "lb RG1, VL2P1($1)",
        "lui $1, VH2",
        "lbu $1, VL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulh",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2P1",
        "lb RG1, LL2P1($1)",
        "lui $1, LH2",
        "lbu $1, LL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulh",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPAP1",
        "lb RG1, LLPP1($1)",
        "lui $1, LHPA",
        "lbu $1, LLP($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulh",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lb RG1, 1(RG3)",
        "lbu $1, 0(RG3)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulh",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "lb RG1, VL2P1($1)",
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lbu $1, VL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulh",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2P1",
        "addu $1, $1, RG4",
        "lb RG1, LL2P1($1)",
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lbu $1, LL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulh",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, sign-extended, starting at effective memory byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPAP1",
        "addu $1, $1, RG6",
        "lb RG1, LLPP1($1)",
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lbu $1, LLP($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulhu",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2P1",
        "lbu RG1, VL2P1($1)",
        "lui $1, VH2",
        "lbu $1, VL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulhu",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2P1",
        "lbu RG1, LL2P1($1)",
        "lui $1, LH2",
        "lbu $1, LL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulhu",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPAP1",
        "lbu RG1, LLPP1($1)",
        "lui $1, LHPA",
        "lbu $1, LLP($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulhu",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lbu RG1, 1(RG3)",
        "lbu $1, 0(RG3)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulhu",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "lbu RG1, VL2P1($1)",
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lbu $1, VL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulhu",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2P1",
        "addu $1, $1, RG4",
        "lbu RG1, LL2P1($1)",
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lbu $1, LL2($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ulhu",
      "format": "pseudo",
      "description": "Unaligned Load Halfword : Set $t1 to the 16 bits, zero-extended, starting at effective memory byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPAP1",
        "addu $1, $1, RG6",
        "lbu RG1, LLPP1($1)",
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lbu $1, LLP($1)",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ld",
      "format": "pseudo",
      "description": "Load Doubleword : Set $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "lw RG1, VL2($1)",
        "lui $1, VH2P4",
        "lw NR1, VL2P4($1)"
      ]
    },
    {
      "name": "ld",
      "format": "pseudo",
      "description": "Load Doubleword : Set $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "lw RG1, LL2($1)",
        "lui $1, LH2P4",
        "lw NR1, LL2P4($1)"
      ]
    },
    {
      "name": "ld",
      "format": "pseudo",
      "description": "Load Doubleword : Set $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lw RG1, LLP($1)",
        "lui $1, LHPAP4",
        "lw NR1, LLPP4($1)"
      ]
    },
    {
      "name": "ld",
      "format": "pseudo",
      "description": "Load Doubleword : Set $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "lw RG1, 0(RG3)",
        "lw NR1, 4(RG3)"
      ]
    },
    {
      "name": "ld",
      "format": "pseudo",
      "description": "Load Doubleword : Set $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lw RG1, VL2($1)",
        "lui $1, VH2P4",
        "addu $1, $1, RG4",
        "lw NR1, VL2P4($1)"
      ]
    },
    {
      "name": "ld",
      "format": "pseudo",
      "description": "Load Doubleword : Set $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lw RG1, LL2($1)",
        "lui $1, LH2P4",
        "addu $1, $1, RG4",
        "lw NR1, LL2P4($1)"
      ]
    },
    {
      "name": "ld",
      "format": "pseudo",
      "description": "Load Doubleword : Set $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lw RG1, LLP($1)",
        "lui $1, LHPAP4",
        "addu $1, $1, RG6",
        "lw NR1, LLPP4($1)"
      ]
    },
    {
      "name": "usw",
      "format": "pseudo",
      "description": "Unaligned Store Word : Store $t1 contents into the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2P3",
        "swl RG1, VL2P3($1)",
        "lui $1, VH2",
        "swr RG1, VL2($1)"
      ]
    },
    {
      "name": "usw",
      "format": "pseudo",
      "description": "Unaligned Store Word : Store $t1 contents into the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2P3",
        "swl RG1, LL2P3($1)",
        "lui $1, LH2",
        "swr RG1, LL2($1)"
      ]
    },
    {
      "name": "usw",
      "format": "pseudo",
      "description": "Unaligned Store Word : Store $t1 contents into the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPAP3",
        "swl RG1, LLPP3($1)",
        "lui $1, LHPA",
        "swr RG1, LLP($1)"
      ]
    },
    {
      "name": "usw",
      "format": "pseudo",
      "description": "Unaligned Store Word : Store $t1 contents into the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "swl RG1, 3(RG3)",
        "swr RG1, 0(RG3)"
      ]
    },
    {
      "name": "usw",
      "format": "pseudo",
      "description": "Unaligned Store Word : Store $t1 contents into the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2P3",
        "addu $1, $1, RG4",
        "swl RG1, VL2P3($1)",
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swr RG1, VL2($1)"
      ]
    },
    {
      "name": "usw",
      "format": "pseudo",
      "description": "Unaligned Store Word : Store $t1 contents into the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2P3",
        "addu $1, $1, RG4",
        "swl RG1, LL2P3($1)",
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swr RG1, LL2($1)"
      ]
    },
    {
      "name": "usw",
      "format": "pseudo",
      "description": "Unaligned Store Word : Store $t1 contents into the 32 bits starting at effective memory byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPAP3",
        "addu $1, $1, RG6",
        "swl RG1, LLPP3($1)",
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swr RG1, LLP($1)"
      ]
    },
    {
      "name": "ush",
      "format": "pseudo",
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "sb RG1, VL2($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, VH2P1",
        "sb RG1, VL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ush",
      "format": "pseudo",
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "sb RG1, LL2($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, LH2P1",
        "sb RG1, LL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ush",
      "format": "pseudo",
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "sb RG1, LLP($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, LHPAP1",
        "sb RG1, LLPP1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ush",
      "format": "pseudo",
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "sb RG1, 0(RG3)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "sb RG1, 1(RG3)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ush",
      "format": "pseudo",
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sb RG1, VL2($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, VH2P1",
        "addu $1, $1, RG4",
        "sb RG1, VL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ush",
      "format": "pseudo",
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sb RG1, LL2($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, LH2P1",
        "addu $1, $1, RG4",
        "sb RG1, LL2P1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "ush",
      "format": "pseudo",
      "description": "Unaligned Store Halfword: Store low-order halfword $t1 contents into the 16 bits starting at effective memory byte address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sb RG1, LLP($1)",
        "sll $1, RG1, 24",
        "srl RG1, RG1, 8",
        "or RG1, RG1, $1",
        "lui $1, LHPAP1",
        "addu $1, $1, RG6",
        "sb RG1, LLPP1($1)",
        "srl $1, RG1, 24",
        "sll RG1, RG1, 8",
        "or RG1, RG1, $1"
      ]
    },
    {
      "name": "sd",
      "format": "pseudo",
      "description": "Store Doubleword : Store contents of $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,100000",
      "templates": [
        "lui $1, VH2",
        "sw RG1, VL2($1)",
        "lui $1, VH2P4",
        "sw NR1, VL2P4($1)"
      ]
    },
    {
      "name": "sd",
      "format": "pseudo",
      "description": "Store Doubleword : Store contents of $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,label",
      "templates": [
        "lui $1, LH2",
        "sw RG1, LL2($1)",
        "lui $1, LH2P4",
        "sw NR1, LL2P4($1)"
      ]
    },
    {
      "name": "sd",
      "format": "pseudo",
      "description": "Store Doubleword : Store contents of $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "sw RG1, LLP($1)",
        "lui $1, LHPAP4",
        "sw NR1, LLPP4($1)"
      ]
    },
    {
      "name": "sd",
      "format": "pseudo",
      "description": "Store Doubleword : Store contents of $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,($t2)",
      "templates": [
        "sw RG1, 0(RG3)",
        "sw NR1, 4(RG3)"
      ]
    },
    {
      "name": "sd",
      "format": "pseudo",
      "description": "Store Doubleword : Store contents of $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sw RG1, VL2($1)",
        "lui $1, VH2P4",
        "addu $1, $1, RG4",
        "sw NR1, VL2P4($1)"
      ]
    },
    {
      "name": "sd",
      "format": "pseudo",
      "description": "Store Doubleword : Store contents of $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sw RG1, LL2($1)",
        "lui $1, LH2P4",
        "addu $1, $1, RG4",
        "sw NR1, LL2P4($1)"
      ]
    },
    {
      "name": "sd",
      "format": "pseudo",
      "description": "Store Doubleword : Store contents of $t1 and the next register to the 64 bits starting at effective memory word address",
      "operandLayout": "$t1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sw RG1, LLP($1)",
        "lui $1, LHPAP4",
        "addu $1, $1, RG6",
        "sw NR1, LLPP4($1)"
      ]
    },
    {
      "name": "lwc1",
      "format": "pseudo",
      "description": "Load Word Coprocessor 1 : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,($t2)",
      "templates": [
        "lwc1 RG1,0(RG3)"
      ]
    },
    {
      "name": "lwc1",
      "format": "pseudo",
      "description": "Load Word Coprocessor 1 : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,-100",
      "templates": [
        "lwc1 RG1,VL2($0)"
      ]
    },
    {
      "name": "lwc1",
      "format": "pseudo",
      "description": "Load Word Coprocessor 1 : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,100000",
      "templates": [
        "lui $1, VH2",
        "lwc1 RG1,VL2($1)"
      ]
    },
    {
      "name": "lwc1",
      "format": "pseudo",
      "description": "Load Word Coprocessor 1 : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwc1 RG1, VL2($1)"
      ]
    },
    {
      "name": "lwc1",
      "format": "pseudo",
      "description": "Load Word Coprocessor 1 : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,label",
      "templates": [
        "lui $1, LH2",
        "lwc1 RG1, LL2($1)",
        "COMPACT",
        "lwc1 RG1, LL2($0)"
      ]
    },
    {
      "name": "lwc1",
      "format": "pseudo",
      "description": "Load Word Coprocessor 1 : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwc1 RG1, LL2($1)",
        "COMPACT",
        "lwc1 RG1, LL2(RG4)"
      ]
    },
    {
      "name": "lwc1",
      "format": "pseudo",
      "description": "Load Word Coprocessor 1 : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lwc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "lwc1",
      "format": "pseudo",
      "description": "Load Word Coprocessor 1 : Set $f1 to 32-bit value from effective memory word address",
      "operandLayout": "$f1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "ldc1",
      "format": "pseudo",
      "description": "Load Doubleword Coprocessor 1 : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,($t2)",
      "templates": [
        "ldc1 RG1,0(RG3)"
      ]
    },
    {
      "name": "ldc1",
      "format": "pseudo",
      "description": "Load Doubleword Coprocessor 1 : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,-100",
      "templates": [
        "ldc1 RG1,VL2($0)"
      ]
    },
    {
      "name": "ldc1",
      "format": "pseudo",
      "description": "Load Doubleword Coprocessor 1 : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,100000",
      "templates": [
        "lui $1, VH2",
        "ldc1 RG1,VL2($1)"
      ]
    },
    {
      "name": "ldc1",
      "format": "pseudo",
      "description": "Load Doubleword Coprocessor 1 : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "ldc1 RG1, VL2($1)"
      ]
    },
    {
      "name": "ldc1",
      "format": "pseudo",
      "description": "Load Doubleword Coprocessor 1 : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,label",
      "templates": [
        "lui $1, LH2",
        "ldc1 RG1, LL2($1)",
        "COMPACT",
        "ldc1 RG1, LL2($0)"
      ]
    },
    {
      "name": "ldc1",
      "format": "pseudo",
      "description": "Load Doubleword Coprocessor 1 : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "ldc1 RG1, LL2($1)",
        "COMPACT",
        "ldc1 RG1, LL2(RG4)"
      ]
    },
    {
      "name": "ldc1",
      "format": "pseudo",
      "description": "Load Doubleword Coprocessor 1 : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,label+100000",
      "templates": [
        "lui $1, LHPA",
        "ldc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "ldc1",
      "format": "pseudo",
      "description": "Load Doubleword Coprocessor 1 : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "ldc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "swc1",
      "format": "pseudo",
      "description": "Store Word Coprocessor 1 : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,($t2)",
      "templates": [
        "swc1 RG1,0(RG3)"
      ]
    },
    {
      "name": "swc1",
      "format": "pseudo",
      "description": "Store Word Coprocessor 1 : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,-100",
      "templates": [
        "swc1 RG1,VL2($0)"
      ]
    },
    {
      "name": "swc1",
      "format": "pseudo",
      "description": "Store Word Coprocessor 1 : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,100000",
      "templates": [
        "lui $1, VH2",
        "swc1 RG1,VL2($1)"
      ]
    },
    {
      "name": "swc1",
      "format": "pseudo",
      "description": "Store Word Coprocessor 1 : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swc1 RG1, VL2($1)"
      ]
    },
    {
      "name": "swc1",
      "format": "pseudo",
      "description": "Store Word Coprocessor 1 : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,label",
      "templates": [
        "lui $1, LH2",
        "swc1 RG1, LL2($1)",
        "COMPACT",
        "swc1 RG1, LL2($0)"
      ]
    },
    {
      "name": "swc1",
      "format": "pseudo",
      "description": "Store Word Coprocessor 1 : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swc1 RG1, LL2($1)",
        "COMPACT",
        "swc1 RG1, LL2(RG4)"
      ]
    },
    {
      "name": "swc1",
      "format": "pseudo",
      "description": "Store Word Coprocessor 1 : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "swc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "swc1",
      "format": "pseudo",
      "description": "Store Word Coprocessor 1 : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "sdc1",
      "format": "pseudo",
      "description": "Store Doubleword Coprocessor 1 : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,($t2)",
      "templates": [
        "sdc1 RG1,0(RG3)"
      ]
    },
    {
      "name": "sdc1",
      "format": "pseudo",
      "description": "Store Doubleword Coprocessor 1 : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,-100",
      "templates": [
        "sdc1 RG1,VL2($0)"
      ]
    },
    {
      "name": "sdc1",
      "format": "pseudo",
      "description": "Store Doubleword Coprocessor 1 : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,100000",
      "templates": [
        "lui $1, VH2",
        "sdc1 RG1,VL2($1)"
      ]
    },
    {
      "name": "sdc1",
      "format": "pseudo",
      "description": "Store Doubleword Coprocessor 1 : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sdc1 RG1, VL2($1)"
      ]
    },
    {
      "name": "sdc1",
      "format": "pseudo",
      "description": "Store Doubleword Coprocessor 1 : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,label",
      "templates": [
        "lui $1, LH2",
        "sdc1 RG1, LL2($1)",
        "COMPACT",
        "sdc1 RG1, LL2($0)"
      ]
    },
    {
      "name": "sdc1",
      "format": "pseudo",
      "description": "Store Doubleword Coprocessor 1 : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sdc1 RG1, LL2($1)",
        "COMPACT",
        "sdc1 RG1, LL2(RG4)"
      ]
    },
    {
      "name": "sdc1",
      "format": "pseudo",
      "description": "Store Doubleword Coprocessor 1 : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,label+100000",
      "templates": [
        "lui $1, LHPA",
        "sdc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "sdc1",
      "format": "pseudo",
      "description": "Store Doubleword Coprocessor 1 : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sdc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "l.s",
      "format": "pseudo",
      "description": "Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address",
      "operandLayout": "$f1,($t2)",
      "templates": [
        "lwc1 RG1,0(RG3)"
      ]
    },
    {
      "name": "l.s",
      "format": "pseudo",
      "description": "Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address",
      "operandLayout": "$f1,-100",
      "templates": [
        "lwc1 RG1,VL2($0)"
      ]
    },
    {
      "name": "l.s",
      "format": "pseudo",
      "description": "Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address",
      "operandLayout": "$f1,100000",
      "templates": [
        "lui $1, VH2",
        "lwc1 RG1,VL2($1)"
      ]
    },
    {
      "name": "l.s",
      "format": "pseudo",
      "description": "Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address",
      "operandLayout": "$f1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "lwc1 RG1, VL2($1)"
      ]
    },
    {
      "name": "l.s",
      "format": "pseudo",
      "description": "Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address",
      "operandLayout": "$f1,label",
      "templates": [
        "lui $1, LH2",
        "lwc1 RG1, LL2($1)",
        "COMPACT",
        "lwc1 RG1, LL2($0)"
      ]
    },
    {
      "name": "l.s",
      "format": "pseudo",
      "description": "Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address",
      "operandLayout": "$f1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "lwc1 RG1, LL2($1)",
        "COMPACT",
        "lwc1 RG1, LL2(RG4)"
      ]
    },
    {
      "name": "l.s",
      "format": "pseudo",
      "description": "Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address",
      "operandLayout": "$f1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "lwc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "l.s",
      "format": "pseudo",
      "description": "Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address",
      "operandLayout": "$f1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "lwc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "s.s",
      "format": "pseudo",
      "description": "Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,($t2)",
      "templates": [
        "swc1 RG1,0(RG3)"
      ]
    },
    {
      "name": "s.s",
      "format": "pseudo",
      "description": "Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,-100",
      "templates": [
        "swc1 RG1,VL2($0)"
      ]
    },
    {
      "name": "s.s",
      "format": "pseudo",
      "description": "Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,100000",
      "templates": [
        "lui $1, VH2",
        "swc1 RG1,VL2($1)"
      ]
    },
    {
      "name": "s.s",
      "format": "pseudo",
      "description": "Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "swc1 RG1, VL2($1)"
      ]
    },
    {
      "name": "s.s",
      "format": "pseudo",
      "description": "Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,label",
      "templates": [
        "lui $1, LH2",
        "swc1 RG1, LL2($1)",
        "COMPACT",
        "swc1 RG1, LL2($0)"
      ]
    },
    {
      "name": "s.s",
      "format": "pseudo",
      "description": "Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "swc1 RG1, LL2($1)",
        "COMPACT",
        "swc1 RG1, LL2(RG4)"
      ]
    },
    {
      "name": "s.s",
      "format": "pseudo",
      "description": "Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,label+100000",
      "templates": [
        "lui $1, LHPA",
        "swc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "s.s",
      "format": "pseudo",
      "description": "Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address",
      "operandLayout": "$f1,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "swc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "l.d",
      "format": "pseudo",
      "description": "Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,($t2)",
      "templates": [
        "ldc1 RG1,0(RG3)"
      ]
    },
    {
      "name": "l.d",
      "format": "pseudo",
      "description": "Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,-100",
      "templates": [
        "ldc1 RG1,VL2($0)"
      ]
    },
    {
      "name": "l.d",
      "format": "pseudo",
      "description": "Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,100000",
      "templates": [
        "lui $1, VH2",
        "ldc1 RG1,VL2($1)"
      ]
    },
    {
      "name": "l.d",
      "format": "pseudo",
      "description": "Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "ldc1 RG1, VL2($1)"
      ]
    },
    {
      "name": "l.d",
      "format": "pseudo",
      "description": "Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,label",
      "templates": [
        "lui $1, LH2",
        "ldc1 RG1, LL2($1)",
        "COMPACT",
        "ldc1 RG1, LL2($0)"
      ]
    },
    {
      "name": "l.d",
      "format": "pseudo",
      "description": "Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "ldc1 RG1, LL2($1)",
        "COMPACT",
        "ldc1 RG1, LL2(RG4)"
      ]
    },
    {
      "name": "l.d",
      "format": "pseudo",
      "description": "Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,label+100000",
      "templates": [
        "lui $1, LHPA",
        "ldc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "l.d",
      "format": "pseudo",
      "description": "Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address",
      "operandLayout": "$f2,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "ldc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "s.d",
      "format": "pseudo",
      "description": "Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,($t2)",
      "templates": [
        "sdc1 RG1,0(RG3)"
      ]
    },
    {
      "name": "s.d",
      "format": "pseudo",
      "description": "Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,-100",
      "templates": [
        "sdc1 RG1,VL2($0)"
      ]
    },
    {
      "name": "s.d",
      "format": "pseudo",
      "description": "Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,100000",
      "templates": [
        "lui $1, VH2",
        "sdc1 RG1,VL2($1)"
      ]
    },
    {
      "name": "s.d",
      "format": "pseudo",
      "description": "Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,100000($t2)",
      "templates": [
        "lui $1, VH2",
        "addu $1, $1, RG4",
        "sdc1 RG1, VL2($1)"
      ]
    },
    {
      "name": "s.d",
      "format": "pseudo",
      "description": "Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,label",
      "templates": [
        "lui $1, LH2",
        "sdc1 RG1, LL2($1)",
        "COMPACT",
        "sdc1 RG1, LL2($0)"
      ]
    },
    {
      "name": "s.d",
      "format": "pseudo",
      "description": "Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,label($t2)",
      "templates": [
        "lui $1, LH2",
        "addu $1, $1, RG4",
        "sdc1 RG1, LL2($1)",
        "COMPACT",
        "sdc1 RG1, LL2(RG4)"
      ]
    },
    {
      "name": "s.d",
      "format": "pseudo",
      "description": "Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,label+100000",
      "templates": [
        "lui $1, LHPA",
        "sdc1 RG1, LLP($1)"
      ]
    },
    {
      "name": "s.d",
      "format": "pseudo",
      "description": "Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address",
      "operandLayout": "$f2,label+100000($t2)",
      "templates": [
        "lui $1, LHPA",
        "addu $1, $1, RG6",
        "sdc1 RG1, LLP($1)"
      ]
    }
  ],
  "directives": [
    {
      "name": ".data",
      "description": "Subsequent items stored in Data segment at next available address"
    },
    {
      "name": ".text",
      "description": "Subsequent items (instructions) stored in Text segment at next available address"
    },
    {
      "name": ".word",
      "description": "Store the listed value(s) as 32 bit words on word boundary"
    },
    {
      "name": ".ascii",
      "description": "Store the string in the Data segment but do not add null terminator"
    },
    {
      "name": ".asciiz",
      "description": "Store the string in the Data segment and add null terminator"
    },
    {
      "name": ".byte",
      "description": "Store the listed value(s) as 8 bit bytes"
    },
    {
      "name": ".align",
      "description": "Align next data item on specified byte boundary (0=byte, 1=half, 2=word, 3=double)"
    },
    {
      "name": ".half",
      "description": "Store the listed value(s) as 16 bit halfwords on halfword boundary"
    },
    {
      "name": ".space",
      "description": "Reserve the next specified number of bytes in Data segment"
    },
    {
      "name": ".double",
      "description": "Store the listed value(s) as double precision floating point"
    },
    {
      "name": ".float",
      "description": "Store the listed value(s) as single precision floating point"
    },
    {
      "name": ".extern",
      "description": "Declare the listed label and byte length to be a global data field"
    },
    {
      "name": ".kdata",
      "description": "Subsequent items stored in Kernel Data segment at next available address"
    },
    {
      "name": ".ktext",
      "description": "Subsequent items (instructions) stored in Kernel Text segment at next available address"
    },
    {
      "name": ".globl",
      "description": "Declare the listed label(s) as global to enable referencing from other files"
    },
    {
      "name": ".set",
      "description": "Set assembler variables.  Currently ignored but included for SPIM compatability"
    },
    {
      "name": ".eqv",
      "description": "Substitute second operand for first. First operand is symbol, second operand is expression (like #define)"
    },
    {
      "name": ".macro",
      "description": "Begin macro definition.  See .end_macro"
    },
    {
      "name": ".end_macro",
      "description": "End macro definition.  See .macro"
    },
    {
      "name": ".include",
      "description": "Insert the contents of the specified file.  Put filename in quotes."
    }
  ],
  "syscalls": [
    {
      "name": "print integer",
      "code": "1",
      "arguments": "$a0 = integer to print",
      "result": ""
    },
    {
      "name": "print float",
      "code": "2",
      "arguments": "$f12 = float to print",
      "result": ""
    },
    {
      "name": "print double",
      "code": "3",
      "arguments": "$f12 = double to print",
      "result": ""
    },
    {
      "name": "print string",
      "code": "4",
      "arguments": "$a0 = address of null-terminated string to print",
      "result": ""
    },
    {
      "name": "read integer",
      "code": "5",
      "arguments": "",
      "result": "$v0 contains integer read"
    },
    {
      "name": "read float",
      "code": "6",
      "arguments": "",
      "result": "$f0 contains float read"
    },
    {
      "name": "read double",
      "code": "7",
      "arguments": "",
      "result": "$f0 contains double read"
    },
    {
      "name": "read string",
      "code": "8",
      "arguments": "$a0 = address of input buffer $a1 = maximum number of characters to read",
      "result": "See note below table"
    },
    {
      "name": "sbrk (allocate heap memory)",
      "code": "9",
      "arguments": "$a0 = number of bytes to allocate",
      "result": "$v0 contains address of allocated memory"
    },
    {
      "name": "exit (terminate execution)",
      "code": "10",
      "arguments": "",
      "result": ""
    },
    {
      "name": "print character",
      "code": "11",
      "arguments": "$a0 = character to print",
      "result": "See note below table"
    },
    {
      "name": "read character",
      "code": "12",
      "arguments": "",
      "result": "$v0 contains character read"
    },
    {
      "name": "open file",
      "code": "13",
      "arguments": "$a0 = address of null-terminated string containing filename $a1 = flags $a2 = mode",
      "result": "$v0 contains file descriptor (negative if error). See note below table"
    },
    {
      "name": "read from file",
      "code": "14",
      "arguments": "$a0 = file descriptor $a1 = address of input buffer $a2 = maximum number of characters to read",
      "result": "$v0 contains number of characters read (0 if end-of-file, negative if error). See note below table"
    },
    {
      "name": "write to file",
      "code": "15",
      "arguments": "$a0 = file descriptor $a1 = address of output buffer $a2 = number of characters to write",
      "result": "$v0 contains number of characters written (negative if error). See note below table"
    },
    {
      "name": "close file",
      "code": "16",
      "arguments": "$a0 = file descriptor",
      "result": ""
    },
    {
      "name": "exit2 (terminate with value)",
      "code": "17",
      "arguments": "$a0 = termination result",
      "result": "See note below table"
    },
    {
      "name": "time (system time)",
      "code": "30",
      "arguments": "",
      "result": "$a0 = low order 32 bits of system time $a1 = high order 32 bits of system time. See note below table"
    },
    {
      "name": "MIDI out",
      "code": "31",
      "arguments": "$a0 = pitch (0-127) $a1 = duration in milliseconds $a2 = instrument (0-127) $a3 = volume (0-127)",
      "result": "Generate tone and return immediately. See note below table"
    },
    {
      "name": "sleep",
      "code": "32",
      "arguments": "$a0 = the length of time to sleep in milliseconds.",
      "result": "Causes the MARS Java thread to sleep for (at least) the specified number of milliseconds. This timing will not be precise, as the Java implementation will add some overhead."
    },
    {
      "name": "print integer in hexadecimal",
      "code": "34",
      "arguments": "$a0 = integer to print",
      "result": "Displayed value is 8 hexadecimal digits, left-padding with zeroes if necessary."
    },
    {
      "name": "print integer in binary",
      "code": "35",
      "arguments": "$a0 = integer to print",
      "result": "Displayed value is 32 bits, left-padding with zeroes if necessary."
    },
    {
      "name": "print integer as unsigned",
      "code": "36",
      "arguments": "$a0 = integer to print",
      "result": "Displayed as unsigned decimal value."
    },
    {
      "name": "(not used)",
      "code": "37-39",
      "arguments": "",
      "result": ""
    },
    {
      "name": "set seed",
      "code": "40",
      "arguments": "$a0 = i.d. of pseudorandom number generator (any int). $a1 = seed for corresponding pseudorandom number generator.",
      "result": "No values are returned. Sets the seed of the corresponding underlying Java pseudorandom number generator ( java.util.Random ). See note below table"
    },
    {
      "name": "random int",
      "code": "41",
      "arguments": "$a0 = i.d. of pseudorandom number generator (any int).",
      "result": "$a0 contains the next pseudorandom, uniformly distributed int value from this random number generator's sequence. See note below table"
    },
    {
      "name": "random int range",
      "code": "42",
      "arguments": "$a0 = i.d. of pseudorandom number generator (any int). $a1 = upper bound of range of returned values.",
      "result": "$a0 contains pseudorandom, uniformly distributed int value in the range 0 See note below table"
    },
    {
      "name": "random float",
      "code": "43",
      "arguments": "$a0 = i.d. of pseudorandom number generator (any int).",
      "result": "$f0 contains the next pseudorandom, uniformly distributed float value in the range 0.0 See note below table"
    },
    {
      "name": "random double",
      "code": "44",
      "arguments": "$a0 = i.d. of pseudorandom number generator (any int).",
      "result": "$f0 contains the next pseudorandom, uniformly distributed double value in the range 0.0 See note below table"
    },
    {
      "name": "(not used)",
      "code": "45-49",
      "arguments": "",
      "result": ""
    },
    {
      "name": "ConfirmDialog",
      "code": "50",
      "arguments": "$a0 = address of null-terminated string that is the message to user",
      "result": "$a0 contains value of user-chosen option 0: Yes 1: No 2: Cancel"
    },
    {
      "name": "InputDialogInt",
      "code": "51",
      "arguments": "$a0 = address of null-terminated string that is the message to user",
      "result": "$a0 contains int read $a1 contains status value 0: OK status -1: input data cannot be correctly parsed -2: Cancel was chosen -3: OK was chosen but no data had been input into field"
    },
    {
      "name": "InputDialogFloat",
      "code": "52",
      "arguments": "$a0 = address of null-terminated string that is the message to user",
      "result": "$f0 contains float read $a1 contains status value 0: OK status -1: input data cannot be correctly parsed -2: Cancel was chosen -3: OK was chosen but no data had been input into field"
    },
    {
      "name": "InputDialogDouble",
      "code": "53",
      "arguments": "$a0 = address of null-terminated string that is the message to user",
      "result": "$f0 contains double read $a1 contains status value 0: OK status -1: input data cannot be correctly parsed -2: Cancel was chosen -3: OK was chosen but no data had been input into field"
    },
    {
      "name": "InputDialogString",
      "code": "54",
      "arguments": "$a0 = address of null-terminated string that is the message to user $a1 = address of input buffer $a2 = maximum number of characters to read",
      "result": "See Service 8 note below table $a1 contains status value 0: OK status. Buffer contains the input string. -2: Cancel was chosen. No change to buffer. -3: OK was chosen but no data had been input into field. No change to buffer. -4: length of the input string exceeded the specified maximum. Buffer contains the maximum allowable input string plus a terminating null."
    },
    {
      "name": "MessageDialog",
      "code": "55",
      "arguments": "$a0 = address of null-terminated string that is the message to user $a1 = the type of message to be displayed: 0: error message, indicated by Error icon --> 1: information message, indicated by Information icon --> 2: warning message, indicated by Warning icon --> 3: question message, indicated by Question icon --> other: plain message (no icon displayed)",
      "result": "N/A"
    },
    {
      "name": "MessageDialogInt",
      "code": "56",
      "arguments": "$a0 = address of null-terminated string that is an information-type message to user $a1 = int value to display in string form after the first string",
      "result": "N/A"
    },
    {
      "name": "MessageDialogFloat",
      "code": "57",
      "arguments": "$a0 = address of null-terminated string that is an information-type message to user $f12 = float value to display in string form after the first string",
      "result": "N/A"
    },
    {
      "name": "MessageDialogDouble",
      "code": "58",
      "arguments": "$a0 = address of null-terminated string that is an information-type message to user $f12 = double value to display in string form after the first string",
      "result": "N/A"
    },
    {
      "name": "MessageDialogString",
      "code": "59",
      "arguments": "$a0 = address of null-terminated string that is an information-type message to user $a1 = address of null-terminated string to display after the first string",
      "result": "N/A"
    }
  ],
  "macros": [
    {
      "symbol": "RGn",
      "meaning": "Substitute the register from source token n."
    },
    {
      "symbol": "NRn",
      "meaning": "Substitute the next higher register after the one in token n."
    },
    {
      "symbol": "OPn",
      "meaning": "Substitute the raw text of token n."
    },
    {
      "symbol": "IMM",
      "meaning": "Substitute the first immediate token from the source statement (or the last token if none found)."
    },
    {
      "symbol": "LLn",
      "meaning": "Low-order 16 bits of the label address in token n."
    },
    {
      "symbol": "LLnU",
      "meaning": "Unsigned low-order 16 bits of the label address in token n."
    },
    {
      "symbol": "LLnPm",
      "meaning": "Low-order 16 bits of the label address in token n after adding m (14)."
    },
    {
      "symbol": "LHn",
      "meaning": "High-order 16 bits of the label address in token n; add 1 if address bit 15 is 1."
    },
    {
      "symbol": "LHnPm",
      "meaning": "High-order 16 bits of the label address in token n after adding m (14); then add 1 if bit 15 is 1."
    },
    {
      "symbol": "VLn",
      "meaning": "Low-order 16 bits of the 32-bit value in token n."
    },
    {
      "symbol": "VLnU",
      "meaning": "Unsigned low-order 16 bits of the 32-bit value in token n."
    },
    {
      "symbol": "VLnPm",
      "meaning": "Low-order 16 bits of the 32-bit value in token n after adding m (14)."
    },
    {
      "symbol": "VLnPmU",
      "meaning": "Unsigned low-order 16 bits of the 32-bit value in token n after adding m (14)."
    },
    {
      "symbol": "VHLn",
      "meaning": "High-order 16 bits of the 32-bit value in token n; pair with VLnU when combining halves."
    },
    {
      "symbol": "VHn",
      "meaning": "High-order 16 bits of the 32-bit value in token n; add 1 if the value's bit 15 is 1."
    },
    {
      "symbol": "VHLnPm",
      "meaning": "High-order 16 bits of the 32-bit value in token n after adding m (14); pair with VLnU when combining halves."
    },
    {
      "symbol": "VHnPm",
      "meaning": "High-order 16 bits of the 32-bit value in token n after adding m (14); then add 1 if bit 15 is 1."
    },
    {
      "symbol": "LLP",
      "meaning": "Low-order 16 bits of a label-plus-immediate expression (immediate added before truncation)."
    },
    {
      "symbol": "LLPU",
      "meaning": "Unsigned low-order 16 bits of a label-plus-immediate expression (immediate added before truncation)."
    },
    {
      "symbol": "LLPPm",
      "meaning": "Low-order 16 bits of a label-plus-immediate expression after applying the m (14) addend before truncation."
    },
    {
      "symbol": "LHPA",
      "meaning": "High-order 16 bits of a label-plus-immediate expression."
    },
    {
      "symbol": "LHPN",
      "meaning": "High-order 16 bits of a label-plus-immediate expression used by la; do not add 1 for bit 15 because ori resolves it."
    },
    {
      "symbol": "LHPAPm",
      "meaning": "High-order 16 bits of a label-plus-immediate expression after applying the m (14) addend."
    },
    {
      "symbol": "LHL",
      "meaning": "High-order 16 bits from the label address in token 2 of an la statement."
    },
    {
      "symbol": "LAB",
      "meaning": "Substitute the textual label from the last token of the source statement."
    },
    {
      "symbol": "S32",
      "meaning": "Substitute 32 minus the constant in the last token (used by ror/rol)."
    },
    {
      "symbol": "DBNOP",
      "meaning": "Insert a delayed-branching NOP when delayed branching is enabled."
    },
    {
      "symbol": "BROFFnm",
      "meaning": "Substitute n if delayed branching is disabled; substitute m if delayed branching is enabled (branch offsets in words)."
    },
    {
      "symbol": "COMPACT",
      "meaning": "Separator between the default template and an optional 16-bit optimized template."
    }
  ]
}